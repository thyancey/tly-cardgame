{"version":3,"sources":["store/context.js","utils/constants.js","themes/index.js","components/card/card.js","components/card/active-card.js","store/helpers/stack.js","store/helpers/meta.js","containers/board/components/draw-zone.js","containers/board/components/drop-zone.js","components/card/hand-card.js","containers/board/components/hand-zone.js","store/helpers/deckmaker.js","store/helpers/gamemaster.js","containers/board/components/round-zone.js","containers/board/components/info-zone.js","containers/board/index.js","utils/use-debounce.js","store/helpers/data.js","store/index.js","components/ui/tooltips.js","containers/main/index.js","serviceWorker.js","index.js"],"names":["StoreContext","React","createContext","holdingIdx","deck","hand","CARDSTATUS","getColor","colorId","store","color","breakpoints","black","grey","grey_light","white","blue","green","yellow","orange","purple","pink","ui_blue","ui_orange","ui_yellow","ui_green","shadow","z1","z2","z3","value","headerHeight","menuWidth","mixins","mobile_tiny","mobile_medium","mobile_large","tablet","desktop","shadowId","S","Card","styled","div","p","theme","depth","isDragging","css","inHand","InnerCard","stackStyle","Background","img","DebugStatus","AbstractCard","statusIdx","onMouseDown","onMouseOver","position","cardRef","dragPosition","data","id","cardIdx","e","stackIdx","layer","ref","style","left","x","top","y","status","Object","keys","find","statusKey","src","info","imageUrl","draggable","ActiveCard","useContext","actions","focusedStackIdx","useState","activeListener","state","setState","useRef","useCallback","setFocusedCardIdx","setFocusedStackIdx","clientX","clientY","holdCard","onMouseDraggingCard","onMouseDroppedCard","dropCard","useEffect","current","addEventListener","removeEventListener","initialized","restingPosition","HAND","useMemo","BOUND_OFFSET","ALPHA","isThisInThat","aA","aB","findIndex","a","indexOf","mergeArrays","concat","filter","b","produceBounds","right","bottom","createBoundedHand","c","TABLE","map","bounds","ThisModule","doesOverlap","bA","bB","getGroupPairs","boundedHand","groupPairs","length","push","createRawStacks","givenGroupPairs","stacks","remainingGroupPairs","slice","matchObj","mutateForGroupPairs","findStackWithMatch","groupPair","stack","calcStacks","matchFound","i","foundStackIdx","splice","getStackColor","getStackLabel","calcStackMeta","cardIdxs","cards","h","produceCards","stackMeta","invalidatedTags","forEach","meta","cMeta","metaInfo","oldMeta","foundIdx","m","tag","count","score","sM","checkTag","some","t","getSortedCardDetails","cardStack","cIdx","cdata","sort","completeStacks","reduce","totalScore","curStack","handLength","Math","round","s","sIdx","idx","cardDetails","subScore","Container","BasicButton","Bg","ZoneText","DrawZone","onClick","dealHand","role","dealCard","discardHand","discardRandomCard","DropZone","props","zoneRef","createRef","onWindowResize","bind","window","this","context","setZone","getBoundingClientRect","Component","contextType","HandCard","Hand","cardsInHand","handPosition","key","shifter","getStartIdxForHand","console","error","createDeckFromData","deckName","deckList","scoreMap","deckIdx","title","getCompleteCardUrl","parseMeta","flat","metaArray","type","produceCard","workOrder","topLayer","filteredDeck","filterDeckToWhatsLeft","warn","deckCard","floor","random","newPos","getCardAtIdx","cardData","card","activeCards","dC","aC","produceHand","cardCount","cardLayer","newHand","startIdx","undefined","newCard","produceDeckHand","deckPath","assetPath","setRoundData","roundData","roundIdx","rounds","setCardPackData","cardPackData","cardPackName","name","cardPack","DeckMaker","getAdjacentRoundIdx","curIdx","change","nextIdx","log","getRound","getRoundDeck","isNaN","roundCardIds","getCardPack","getRoundData","targetScore","getStore","getNumRounds","RoundButton","isActive","TextArea","CardCount","RoundZone","numCardsInDrawPile","prevRound","buttons","setRound","renderRounds","GameMaster","nextRound","ScoreGroup","TotalScore","TargetScore","SubScore","InfoZone","MetaHelper","Board","PlayArea","StackInfoZone","DiscardZone","BgImage","CardContainer","HeldCardContainer","dataLoaded","mouseCoords","setMouseCoords","onBgMouseOver","packUrl","URLSearchParams","location","search","get","loadData","cardsOnTable","DISCARDED","debouncedCoords","timeout","handler","setTimeout","clearTimeout","useDebounce","onMouseMove","action","url","callback","xhr","XMLHttpRequest","open","send","onreadystatechange","readyState","gameData","JSON","parse","responseText","Store","children","setHoldingIdx","tooltipCoords","setTooltipCoords","focusedCardIdx","setHandRaw","setDeck","zones","setZones","setStacks","setDataLoaded","setAllRoundData","newRoundIdx","packName","dataUrl","DataHelper","pack","setHand","responsibleIdx","StackHelper","discardCard","cardLimit","randHandIdx","zoneId","z","dropCardStatus","HAND_HOLDING","TABLE_HOLDING","droppedStatus","placeCardInHand","setFocusedStackIdxHelper","focusedIdx","newPosition","foundCard","activeZones","getZonesAtPosition","az","Provider","MetaLine","MetaTag","MetaTagLabel","MetaTagValue","toString","MetaScore","StackEntry","StackTotal","Tooltips","Tooltip","li","tooltipCss","gm","dm","Main","Boolean","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.0b55470d.chunk.js","sourcesContent":["import React from 'react';\n\nexport const InitialState = {\n  holdingIdx: 0,\n  deck: [],\n  hand: []\n};\n\nexport const StoreContext = React.createContext(InitialState);","export const CARDSTATUS = {\r\n  'DECK':0,\r\n  'HAND':1,\r\n  'HAND_HOLDING':2,\r\n  'TABLE':3,\r\n  'TABLE_HOLDING':4,\r\n  'DISCARDED':5\r\n}\r\n\r\nexport const getCardStatusLabel = statusIdx => {\r\n  return Object.keys(CARDSTATUS).find(statusKey => CARDSTATUS[statusKey] === statusIdx) || 'NULL';\r\n}\r\n\r\nexport default {};","import { css } from 'styled-components';\n\nexport const themeGet = (...args) => props => {\n  let current = props.theme;\n  for (const arg of args) {\n    if (!current[arg]) {\n      console.error('[Theming] Could not find', arg, 'in', current);\n      return '';\n    }\n    current = current[arg];\n  }\n  return current;\n};\n\nexport const mixinFontFamily = (style) => {\n  switch(style){\n    case 'details' : return css`font-family: 'Roboto', sans-serif`;\n    case 'display': return css`font-family: 'Bevan', cursive`;\n    default: return css`font-family: 'Roboto', sans-serif`;\n  }\n}\n\n/* MIXINS */\nexport const mixin_clearBubble = () => {\n  return css`\n    border: .2rem solid rgba(255, 255, 255, 0.2);\n    border-color: rgba(255, 255, 255, 0.2) rgba(0, 0, 0, 0.2) rgba(0, 0, 0, 0.2) rgba(255, 255, 255, 0.2);\n    border-radius: 1rem;\n    box-shadow: .1rem .1rem .5rem black;\n  `;\n}\n\nexport const mixin_textStroke = (thickness, spread, color) => {\n  return css`\n    text-shadow:  -${thickness} -${thickness} ${spread} ${color},\n                  ${thickness} -${thickness} ${spread} ${color},\n                  -${thickness} ${thickness} ${spread} ${color},\n                  ${thickness} ${thickness} ${spread} ${color},\n                  -${thickness} -${thickness} ${spread} ${color},\n                  ${thickness} -${thickness} ${spread} ${color},\n                  -${thickness} ${thickness} ${spread} ${color},\n                  ${thickness} ${thickness} ${spread} ${color},\n                  -${thickness} -${thickness} ${spread} ${color},\n                  ${thickness} -${thickness} ${spread} ${color},\n                  -${thickness} ${thickness} ${spread} ${color},\n                  ${thickness} ${thickness} ${spread} ${color},\n                  -${thickness} -${thickness} ${spread} ${color},\n                  ${thickness} -${thickness} ${spread} ${color},\n                  -${thickness} ${thickness} ${spread} ${color},\n                  ${thickness} ${thickness} ${spread} ${color};\n  `;\n}\n\n\n/* COLORS */\nexport const listColors = () => {\n  return Object.keys(store.color);\n}\n\nexport const getColor = (colorId) => {\n  return store.color[colorId];\n}\n\nexport const getShadow = (shadowId) => {\n  return store.shadow[shadowId];\n}\n\n\n/* from pablo on https://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors */\nexport const shadeColor = (colId, percent) => {\n  var color = store.color[colId] || colId;\n\n  var R = parseInt(color.substring(1,3),16);\n  var G = parseInt(color.substring(3,5),16);\n  var B = parseInt(color.substring(5,7),16);\n\n  R = parseInt(R * (100 + percent) / 100);\n  G = parseInt(G * (100 + percent) / 100);\n  B = parseInt(B * (100 + percent) / 100);\n\n  R = (R<255)?R:255;  \n  G = (G<255)?G:255;  \n  B = (B<255)?B:255;  \n\n  var RR = ((R.toString(16).length===1)?\"0\"+R.toString(16):R.toString(16));\n  var GG = ((G.toString(16).length===1)?\"0\"+G.toString(16):G.toString(16));\n  var BB = ((B.toString(16).length===1)?\"0\"+B.toString(16):B.toString(16));\n\n  return \"#\"+RR+GG+BB;\n}\n\n/* BREAKPOINTS */\n/* https://jsramblings.com/how-to-use-media-queries-with-styled-components/ */\nconst breakpoints = {\n  mobile_tiny: '300px',\n  mobile_medium: '400px',\n  mobile_large: '500px',\n  tablet: '768px',\n  desktop: '1024px'\n}\n\nexport const getBreakpoint = {\n  mobile_tiny: `(min-width: ${breakpoints.mobile_tiny})`,\n  mobile_medium: `(min-width: ${breakpoints.mobile_medium})`,\n  mobile_large: `(min-width: ${breakpoints.mobile_large})`,\n  tablet: `(min-width: ${breakpoints.tablet})`,\n  desktop: `(min-width: ${breakpoints.desktop})`\n};\n\nconst store = {\n  color:{\n    black: '#000000',\n    grey: '#373737',\n    grey_light: '#A39F8E',\n    white: '#ffffff',\n    blue: '#225C87',\n    green: '#238845',\n    yellow: '#688722',\n    orange: '#688722',\n    purple: '#5E238C',\n    pink: '#85227E',\n    ui_blue: '#20F3FF',\n    ui_orange: '#FD9410',\n    ui_yellow: '#FDE010',\n    ui_green: '#10FD21',\n  },\n  shadow:{\n    z1: '-0.1rem 0.1rem .25rem .1rem rgba(0,0,0,0.16)',\n    z2: '-0.1rem 0.1rem .25rem .1rem rgba(0,0,0,0.36)',\n    z3: '-.2rem .5rem 1rem .2rem rgba(0,0,0,.36)'\n  },\n  value:{\n    headerHeight: '7.5rem',\n    menuWidth: '12rem'\n  },\n  mixins:{},\n  breakpoints:{\n    mobile_tiny: '300px',\n    mobile_medium: '400px',\n    mobile_large: '500px',\n    tablet: '768px',\n    desktop: '1024px'\n  }\n}\n\nexport default store;\n","import React from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport { mixin_textStroke, getShadow, getColor } from '../../themes/index';\r\n// import InnerCard from './inner-card';\r\nimport { getCardStatusLabel } from '../../utils/constants';\r\n\r\nconst S = {};\r\n\r\nS.Card = styled.div`\r\n  background-color: ${p => p.theme || 'white'};\r\n  border-radius:1rem;\r\n  color:black;\r\n  cursor:pointer;\r\n  z-index: ${p => p.depth};\r\n  ${p => p.isDragging && css`\r\n    z-index:1000;\r\n  `}\r\n\r\n  ${p => p.inHand ? css`\r\n    display:inline-block;\r\n    position:relative;\r\n    width:10rem;\r\n    height:15rem;\r\n    top:-5rem;\r\n  `:css`\r\n    position:absolute;\r\n  `}\r\n`;\r\n\r\nS.InnerCard = styled.div`\r\n  position:absolute;\r\n  width:10rem;\r\n  height:15rem;\r\n  transform-origin: 50% 50%;\r\n  ${p => p.inHand ? css`\r\n    left: 0;\r\n    top: 0;\r\n  `:css`\r\n    left: -5rem;\r\n    top: -7.5rem;\r\n  `}\r\n  \r\n  transition: transform .3s cubic-bezier(1,.05,.32,1.2), opacity .3s;\r\n  border-radius: 1rem;\r\n  \r\n  box-shadow: ${getShadow('z3')};\r\n  ${p => p.stackStyle === 'stacked' && css`\r\n    box-shadow: 1px 3px 2px 4px ${getColor('ui_blue')};\r\n  `}\r\n  ${p => p.stackStyle === 'focused' && css`\r\n    box-shadow: 1px 3px 2px 4px ${getColor('ui_green')};\r\n  `}\r\n\r\n  ${p => p.isDragging && css`\r\n    transform: scaleX(1.5) scaleY(1.5);\r\n    opacity: .5;\r\n    transition: transform .1s cubic-bezier(.42,.05,.86,.13), opacity .2s;\r\n  `}\r\n`;\r\n\r\nS.Background = styled.img`\r\n  background-size: contain;\r\n  width:100%;\r\n  height:100%;\r\n  border-radius:1rem;\r\n`;\r\n\r\nS.DebugStatus = styled.p`\r\n  color:white;\r\n  position:absolute;\r\n  bottom:100%;\r\n`\r\n\r\nfunction AbstractCard({ onMouseDown, onMouseOver, position, cardRef, stackStyle, dragPosition, inHand, data, theme='white' }) {\r\n  return (\r\n    <S.Card\r\n      id={`card-${data.cardIdx}`} \r\n      theme={theme} \r\n      isDragging={!!dragPosition}\r\n      onMouseDown={e => onMouseDown(e, data.cardIdx)}\r\n      onMouseOver={e => onMouseOver(e, data.cardIdx, data.stackIdx)}\r\n      depth={data.layer}\r\n      ref={cardRef}\r\n      inHand={inHand}\r\n      style={inHand ? null : {\r\n        left: `${position.x}px`,\r\n        top: `${position.y}px`,\r\n      }}\r\n    >\r\n      <S.InnerCard \r\n        isDragging={!!dragPosition}\r\n        inHand={inHand}\r\n        stackStyle={stackStyle}\r\n      >\r\n        <S.DebugStatus>{getCardStatusLabel(data.status)}</S.DebugStatus>\r\n        <S.Background src={data.info.imageUrl} draggable={false} />\r\n      </S.InnerCard>\r\n    </S.Card>\r\n  );\r\n}\r\n\r\nexport default AbstractCard;\r\n","import React, { useState, useEffect, useContext, useCallback, useRef, useMemo } from 'react';\r\nimport { StoreContext } from '../../store/context';\r\nimport { CARDSTATUS } from '../../utils/constants';\r\nimport Card from './card';\r\n\r\nconst S = {};\r\n\r\nfunction usePosition(restingPosition, dragPosition, status){\r\n  if(status === CARDSTATUS.HAND){\r\n    return {\r\n      x: 0,\r\n      y: 0\r\n    }\r\n  }\r\n\r\n  if(!!dragPosition){\r\n    return {\r\n      x: dragPosition.x,\r\n      y: dragPosition.y\r\n    }\r\n  }else{\r\n    return {\r\n      x: restingPosition.x,\r\n      y: restingPosition.y\r\n    }\r\n  }\r\n}\r\n\r\nfunction ActiveCard({ data, theme='white' }) {\r\n  const { actions, focusedStackIdx } = useContext(StoreContext);\r\n\r\n  const [ state, setState ] = useState({\r\n    dragPosition: null,\r\n    activeListener: false\r\n  });\r\n\r\n  const cardRef = useRef(null);\r\n  \r\n  const onMouseOver = useCallback((e, cardIdx, stackIdx) => {\r\n    actions.setFocusedCardIdx(cardIdx);\r\n    actions.setFocusedStackIdx(stackIdx, { x: e.clientX, y: e.clientY });\r\n  }, [ actions.setFocusedStackIdx, actions.setFocusedCardIdx ]);\r\n\r\n  const onMouseDown = useCallback(({ clientX, clientY }, cardIdx) => {\r\n    actions.holdCard(cardIdx);\r\n\r\n    setState(state => ({\r\n      ...state,\r\n      activeListener: true,\r\n      dragPosition: {\r\n        x: clientX,\r\n        y: clientY\r\n      }\r\n    }));\r\n  }, [ actions.holdCard ]);\r\n\r\n  const onMouseDraggingCard = useCallback(({ clientX, clientY }) => {\r\n    // console.log('onMouseDraggingCard')\r\n    setState(state => ({\r\n      ...state,\r\n      dragPosition: {\r\n        x: clientX,\r\n        y: clientY\r\n      }\r\n    }));\r\n\r\n  }, []);\r\n\r\n  const onMouseDroppedCard = useCallback(({ clientX, clientY }) => {\r\n    setState(state => ({\r\n      ...state,\r\n      activeListener: false,\r\n      dragPosition:null\r\n    }));\r\n\r\n    // console.log('simple: mouseDropped', data.cardIdx);\r\n    actions.dropCard(data.cardIdx, 'TABLE', {\r\n      x: clientX,\r\n      y: clientY\r\n    });\r\n\r\n  }, [ data.cardIdx, actions.dropCard ]);\r\n\r\n  useEffect(() => {\r\n    if(state.activeListener){\r\n      cardRef.current.addEventListener('mouseleave', onMouseDroppedCard);\r\n      cardRef.current.addEventListener('mousemove', onMouseDraggingCard);\r\n      cardRef.current.addEventListener('mouseup', onMouseDroppedCard);\r\n    }else {\r\n      cardRef.current.removeEventListener('mouseleave', onMouseDroppedCard);\r\n      cardRef.current.removeEventListener('mousemove', onMouseDraggingCard);\r\n      cardRef.current.removeEventListener('mouseup', onMouseDroppedCard);\r\n    }\r\n  }, [ state.activeListener ]);\r\n\r\n  //- keeps position when selecting card from hand\r\n  useEffect(() => {\r\n    if(!state.initialized){\r\n      setState(state => ({\r\n        ...state,\r\n        activeListener:true,\r\n        dragPosition: {\r\n          x: data.position.x,\r\n          y: data.position.y\r\n        }\r\n      }));\r\n    }\r\n  }, [ state.initialized ]);\r\n\r\n  let position = usePosition(data.position, state.dragPosition, data.status);\r\n\r\n  const stackStyle = useMemo(() => \r\n    {\r\n      if(data.stackIdx === -1){\r\n        return null;\r\n      }else{\r\n        if(focusedStackIdx === data.stackIdx){\r\n          return 'focused';\r\n        }else{\r\n          return 'stacked';\r\n        }\r\n      }\r\n    },\r\n    [ data.stackIdx, focusedStackIdx ]\r\n  );\r\n\r\n  return (\r\n    <Card\r\n      data={data}\r\n      theme={theme} \r\n      onMouseDown={onMouseDown}\r\n      onMouseOver={onMouseOver}\r\n      cardRef={cardRef}\r\n      inHand={false}\r\n      position={position}\r\n      dragPosition={state.dragPosition}\r\n      stackStyle={stackStyle} >\r\n    </Card>\r\n  );\r\n}\r\n\r\nexport default ActiveCard;\r\n","import ThisModule from './stack';\r\nimport { CARDSTATUS } from '../../utils/constants';\r\n\r\nconst BOUND_OFFSET = {\r\n  W: 50,\r\n  H: 75\r\n};\r\n\r\nconst isThisInThat = (aA, aB) => {\r\n  if(!aA || !aB) return false;\r\n  let foundIdx = aA.findIndex(a => aB.indexOf(a) > -1);\r\n  return foundIdx > -1;\r\n};\r\n\r\nconst mergeArrays = (aA, aB) => {\r\n  aA = aA || [];\r\n  aB = aB || [];\r\n  return aA.concat(aB.filter((b) => aA.indexOf(b) < 0));\r\n};\r\n\r\nconst produceBounds = position => {\r\n  return {\r\n    left: position.x - BOUND_OFFSET.W,\r\n    top: position.y - BOUND_OFFSET.H,\r\n    right: position.x + BOUND_OFFSET.W,\r\n    bottom: position.y + BOUND_OFFSET.H\r\n  }\r\n};\r\n\r\n// cards only start with position, calc the bounds once please\r\nconst createBoundedHand = hand => {\r\n  // only stack cards in play\r\n  return hand.filter(c => c.status === CARDSTATUS.TABLE).map(c => ({\r\n    cardIdx: c.cardIdx,\r\n    bounds: ThisModule.produceBounds(c.position)\r\n  }));\r\n};\r\n\r\nconst doesOverlap = (bA, bB) => {\r\n  return bA.top <= bB.bottom && bA.bottom >= bB.top && bA.left <= bB.right && bA.right >= bB.left;\r\n};\r\n\r\n// do some weird loopin to avoid checking the same pair twice\r\nconst getGroupPairs = boundedHand => {\r\n  const groupPairs = [];\r\n\r\n  // do some weird loopin to avoid checking the same pair twice\r\n  for(let a = 0; a < boundedHand.length; a++){\r\n    for(let b = a + 1; b < boundedHand.length; b++){\r\n      if(ThisModule.doesOverlap(boundedHand[a].bounds, boundedHand[b].bounds)){\r\n        groupPairs.push([boundedHand[a].cardIdx, boundedHand[b].cardIdx]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return groupPairs;\r\n}\r\n\r\nconst findStackWithMatch = (stacks, groupPair) => {\r\n  return stacks.findIndex(stack => (stack.indexOf(groupPair[0]) > -1 || stack.indexOf(groupPair[1]) > -1));\r\n}\r\n\r\n/*\r\n  //- now have a list of..\r\n    [0, 1]\r\n    [1, 2]\r\n    [4, 5]\r\n\r\n  // so convert to\r\n    [0, 1, 2]\r\n    [4, 5]\r\n*/\r\nconst mutateForGroupPairs = (stacks, groupPairs) => {\r\n  let matchFound = false;\r\n\r\n  // find the next stack\r\n  for(let i = groupPairs.length - 1; i >= 0; i--){\r\n    const foundStackIdx = ThisModule.findStackWithMatch(stacks, groupPairs[i]);\r\n    if(stacks.length === 0){\r\n      stacks.push(groupPairs[i]);\r\n      groupPairs.splice(i, 1);\r\n      matchFound = true;\r\n    } else if(foundStackIdx > -1){\r\n      stacks[foundStackIdx] = ThisModule.mergeArrays(stacks[foundStackIdx], groupPairs[i]);\r\n      groupPairs.splice(i, 1);\r\n      matchFound = true;\r\n    }\r\n  }\r\n  \r\n  if(!matchFound && groupPairs.length > 0){\r\n    stacks.push(groupPairs[groupPairs.length - 1]);\r\n  }\r\n\r\n  return {\r\n    stacks: stacks,\r\n    groupPairs: groupPairs\r\n  };\r\n}\r\n\r\nconst createRawStacks = givenGroupPairs => {\r\n  if(!givenGroupPairs || givenGroupPairs.length === 0) return [];\r\n\r\n  let stacks = [];\r\n  let remainingGroupPairs = givenGroupPairs.slice();\r\n  while(remainingGroupPairs.length > 0){\r\n    // find the next stack\r\n    const matchObj = ThisModule.mutateForGroupPairs(stacks, remainingGroupPairs);\r\n    stacks = matchObj.stacks;\r\n    remainingGroupPairs = matchObj.groupPairs;\r\n  }\r\n\r\n  return stacks;\r\n}\r\n\r\n/* This works, but sure seems like it could be simplified!\r\n  - compares bounds of all cards\r\n  - returns list of \"stacks\" of unique cardIdxs that are touching\r\n  - there is so much dirty mutation throughout here and probably some big inefficiencies\r\n  ->  [ [ 0, 2, 5], [ 1, 3 ] ]\r\n*/\r\nconst calcStacks = (hand) => {\r\n  const boundedHand = ThisModule.createBoundedHand(hand);\r\n  const groupPairs = ThisModule.getGroupPairs(boundedHand);\r\n  const rawStacks = ThisModule.createRawStacks(groupPairs);\r\n  return rawStacks;\r\n};\r\n\r\n\r\nconst getStackColor = (stackIdx) => {\r\n  switch(stackIdx){\r\n    case -1: return null;\r\n    case 0: return 'purple';\r\n    case 1: return 'blue';\r\n    case 2: return 'green';\r\n    case 3: return 'yellow';\r\n    case 4: return 'red';\r\n    case 5: return 'grey';\r\n    default: return 'black';\r\n  }\r\n};\r\n\r\nconst ALPHA = [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L' ]\r\nconst getStackLabel = stackIdx => {\r\n  return ALPHA[stackIdx] || '*';\r\n};\r\n\r\nexport default {\r\n  isThisInThat: isThisInThat,\r\n  mergeArrays: mergeArrays,\r\n  produceBounds: produceBounds,\r\n  createBoundedHand: createBoundedHand,\r\n  doesOverlap: doesOverlap,\r\n  getGroupPairs: getGroupPairs,\r\n  createRawStacks: createRawStacks,\r\n  findStackWithMatch: findStackWithMatch,\r\n  calcStacks: calcStacks,\r\n  mutateForGroupPairs: mutateForGroupPairs,\r\n  getStackColor: getStackColor,\r\n  getStackLabel: getStackLabel,\r\n};\r\n","const newMetaGroup = metaInfo => ({\n  tag: metaInfo.tag,\n  value: metaInfo.value,\n  score: metaInfo.score,\n  count: 1\n});\n\nconst mergeMetaGroup = (oldMeta, newMeta) => ({\n  ...oldMeta,\n  count: oldMeta.count + 1\n});\n\nconst produceCards = (cardIdxs, hand) => cardIdxs.map((cardIdx) => hand.find(h => h.cardIdx === cardIdx));\nconst foundInTags = (checkTag, tags) => tags.some(t => t === checkTag);\n\nconst calcStackMeta = ( cardIdxs, hand ) => {\n  const cards = produceCards(cardIdxs, hand);\n\n  let stackMeta = [];\n  let invalidatedTags = [];\n  cards.forEach(c => {\n    c.info.meta.forEach(cMeta => {\n      const foundIdx = stackMeta.findIndex(m => m.tag === cMeta.tag);\n      if(foundIdx > -1){\n        /* for now, tag/value combos must match for card to aggregate..\n           if \"color\":\"red\", dont wanna aggregate any new meta where \"color\":\"blue\", etc\n        */\n        if(stackMeta[foundIdx].value === cMeta.value){\n          stackMeta[foundIdx] = mergeMetaGroup(stackMeta[foundIdx], cMeta);\n        }else{\n          //- tag/value combo doesnt match for this card\n          //- maybe later, invalidate tag group\n          if(invalidatedTags.indexOf(cMeta.tag) === -1) invalidatedTags.push(cMeta.tag);\n        }\n      }else{\n        stackMeta.push(newMetaGroup(cMeta));\n      }\n    })\n  });\n\n  return stackMeta\n    .filter(sM => !foundInTags(sM.tag, invalidatedTags)) //- remove any invalid groups\n    .filter(sM => sM.count === cardIdxs.length); //- if meta doesnt match all, remove it (TODO, bonus cards later)\n}\n\nconst getSortedCardDetails = (cardStack, hand) => \n  cardStack.map(cIdx => {\n    const cdata = hand.find(c => c.cardIdx === cIdx);\n    return {\n      ...cdata.info,\n      layer: cdata.layer\n    }\n  }).sort((a,b) => (a.layer > b.layer) ? 1 : -1);\n\n/* external */\nconst calcCompleteStacks = (stacks, hand) => stacks.map((s, sIdx) => {\n  const stackMeta = calcStackMeta(s, hand);\n\n  return {\n    idx: sIdx,\n    cardIdxs: s,\n    cardDetails: getSortedCardDetails(s, hand),\n    count: s.length,\n    meta: stackMeta,\n    subScore: stackMeta.reduce(((totalScore, meta) => totalScore + meta.score), 0),\n    score: stackMeta.reduce(((totalScore, meta) => totalScore + (meta.count * meta.score)), 0)\n  }\n});\nconst calcTotalScore = completeStacks => completeStacks.reduce(((totalScore, curStack) => curStack.score + totalScore), 0);\nconst calcSpcScore = (totalScore, handLength) => (handLength > 0 && Math.round(totalScore / handLength)) || 0;\n\nexport default {\n  calcTotalScore: calcTotalScore,\n  calcSpcScore: calcSpcScore,\n  calcCompleteStacks: calcCompleteStacks,\n};\n","import React, { useContext, useMemo } from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport { StoreContext } from '../../../store/context';\r\nimport StackHelper from '../../../store/helpers/stack';\r\nimport MetaHelper from '../../../store/helpers/meta';\r\nimport { getColor } from '../../../themes/index';\r\n\r\nconst S = {};\r\n\r\nS.Container = styled.div`\r\n  width:15rem;\r\n  min-height:22rem;\r\n  padding:2rem;\r\n`;\r\n\r\nS.BasicButton = styled.div`\r\n  padding: .5rem 1.5rem;\r\n  font-size: 1rem;\r\n  background-color: ${getColor('purple')};\r\n  border-radius: 1rem;\r\n  width: 100%;\r\n  font-weight: bold;\r\n  cursor:pointer;\r\n\r\n  border: .5rem solid ${getColor('white')};\r\n  color:${getColor('white')};\r\n  &:first-child{\r\n    margin-top:0;\r\n  }\r\n  margin-top: .5rem;\r\n\r\n  &:hover{\r\n    background-color: ${getColor('green')};\r\n    /* color:${getColor('blue')}; */\r\n    box-shadow: 0 0 1rem .2rem white;\r\n  }\r\n`;\r\n\r\nS.Bg = styled.div`\r\n  position:absolute;\r\n  z-index:-1;\r\n  left:0;\r\n  top:0;\r\n  right:0;\r\n  bottom:0;\r\n  border-radius: 2rem;\r\n  border: 1rem solid white;\r\n`;\r\n\r\nS.ZoneText = styled.p`\r\n  position:absolute;\r\n  padding-top: 1rem;\r\n  top:100%;\r\n  width:100%;\r\n  left:0;\r\n  text-align:center;\r\n  color:${getColor('white')}\r\n`;\r\n\r\nfunction DrawZone() {\r\n  const { actions } = useContext(StoreContext);\r\n\r\n  return (\r\n    <S.Container >\r\n      <S.BasicButton onClick={() => actions.dealHand()} role=\"button\">\r\n        {'DEAL'}\r\n      </S.BasicButton>\r\n      <S.BasicButton onClick={() => actions.dealCard(1)} role=\"button\">\r\n        {'DRAW 1 MORE'}\r\n      </S.BasicButton>\r\n      <S.BasicButton onClick={() => actions.discardHand()} role=\"button\">\r\n        {'DISCARD ALL'}\r\n      </S.BasicButton>\r\n      <hr/>\r\n      <S.BasicButton onClick={() => actions.dealCard(10)} role=\"button\">\r\n        {'HIT 10'}\r\n      </S.BasicButton>\r\n      <S.BasicButton onClick={() => actions.discardRandomCard()} role=\"button\">\r\n        {'DISCARD RANDOM'}\r\n      </S.BasicButton>\r\n      <S.ZoneText>{'DRAW'}</S.ZoneText>\r\n      <S.Bg />\r\n    </S.Container>\r\n  );\r\n}\r\n\r\nexport default DrawZone;\r\n","import React from 'react';\r\nimport styled, { } from 'styled-components';\r\nimport { StoreContext } from '../../../store/context';\r\n\r\nconst S = {};\r\n\r\nS.Container = styled.div`\r\n  width: 100%;\r\n  height: 100%;\r\n  p{\r\n    opacity:0;\r\n    color: white;\r\n    transition: opacity .1s;\r\n    text-align:left;\r\n    margin-left:1rem;\r\n  }\r\n  transition: box-shadow 1s;\r\n\r\n  &:hover{\r\n    box-shadow: 0 0 1rem .2rem white;\r\n    transition-delay: .5s;\r\n    p{\r\n      opacity:1;\r\n      transition: opacity 1s;\r\n      transition-delay: .7s;\r\n    }\r\n  }\r\n`;\r\n\r\n/* \r\n  TODO, tried this with hooks but couldnt get it to stop doing an infinite re-render with refs and useEffect\r\n*/\r\nclass DropZone extends React.Component{\r\n  static contextType = StoreContext;\r\n\r\n  constructor(props) {\r\n    super(props)\r\n    this.zoneRef = React.createRef();\r\n    this.onWindowResize = this.onWindowResize.bind(this);\r\n  }\r\n\r\n  componentDidMount(){\r\n    window.addEventListener('resize', this.onWindowResize);\r\n    this.context.actions.setZone('hand', this.zoneRef?.current?.getBoundingClientRect());\r\n  }\r\n\r\n  componentWillUnmount(){\r\n    window.removeEventListener('resize', this.onWindowResize);\r\n  }\r\n\r\n  onWindowResize(){\r\n    this.context.actions.setZone('hand', this.zoneRef?.current?.getBoundingClientRect());\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <S.Container \r\n        ref={this.zoneRef} >\r\n        <p>{'Return card to hand'}</p>\r\n      </S.Container>\r\n    )\r\n  };\r\n}\r\n\r\nexport default DropZone;\r\n","import React, { useState, useContext, useCallback, useRef } from 'react';\r\nimport { StoreContext } from '../../store/context';\r\nimport Card from './card';\r\n\r\nconst S = {};\r\n\r\nfunction HandCard({ data, theme='white' }) {\r\n  const { actions } = useContext(StoreContext);\r\n\r\n  const [ state, setState ] = useState({\r\n    dragPosition: null\r\n  });\r\n\r\n  const cardRef = useRef(null);\r\n  \r\n  const onMouseOver = useCallback((e, cardIdx, stackIdx) => {\r\n    actions.setFocusedCardIdx(cardIdx);\r\n    actions.setFocusedStackIdx(stackIdx, { x: e.clientX, y: e.clientY });\r\n  }, [ actions.setFocusedStackIdx, actions.setFocusedCardIdx ]);\r\n\r\n\r\n  const onMouseDown = useCallback(({ clientX, clientY }, cardIdx) => {\r\n    actions.holdCard(cardIdx, {\r\n      x: clientX,\r\n      y: clientY\r\n    });\r\n  }, [ actions.holdCard, actions.dropCard ]);\r\n\r\n  return (\r\n    <Card\r\n      data={data}\r\n      theme={theme} \r\n      onMouseDown={onMouseDown}\r\n      onMouseOver={onMouseOver}\r\n      cardRef={cardRef}\r\n      inHand={true}\r\n      position={{x:0,y:0}}\r\n      dragPosition={state.dragPosition}\r\n      stackStyle={'hand'} >\r\n    </Card>\r\n  );\r\n}\r\n\r\nexport default HandCard;\r\n","import React, { useContext, useMemo } from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport { StoreContext } from '../../../store/context';\r\nimport HandCard from '../../../components/card/hand-card';\r\nimport { CARDSTATUS } from '../../../utils/constants';\r\n\r\nconst S = {};\r\n\r\nS.Hand = styled.div`\r\n  position:absolute;\r\n  width:100%;\r\n  height:6rem;\r\n  bottom:0px;\r\n\r\n  background-color:black;\r\n  border-top: 1rem solid white;\r\n`;\r\n\r\nfunction Hand() {\r\n  const { hand } = useContext(StoreContext);\r\n\r\n  const cardsInHand = useMemo(() => {\r\n      const validCards = hand.filter(h => h.status === CARDSTATUS.HAND).map((c, idx) => ({\r\n        ...c,\r\n        handPosition: idx\r\n      }));\r\n      return validCards;\r\n    },\r\n    [ hand ]\r\n  );\r\n  // const cardsInHand = [];\r\n\r\n  return (\r\n    <S.Hand id=\"hand\">\r\n      {cardsInHand.map(c => (\r\n        <HandCard data={c} key={c.cardIdx} />\r\n      ))}\r\n    </S.Hand>\r\n  );\r\n}\r\n\r\nexport default Hand;\r\n","import { CARDSTATUS } from '../../utils/constants';\r\nimport ThisModule from './deckmaker';\r\n\r\nconst parseMeta = (metaArray, scoreMap) => {\r\n  if(!metaArray) return [];\r\n\r\n  return metaArray.map(m => ({\r\n    tag: m[0],\r\n    value: m[1],\r\n    type: typeof m[1],\r\n    score: scoreMap[m[0]] || 0\r\n  }));\r\n}\r\n\r\nconst getCompleteCardUrl = (c, deckPath) => {\r\n  if(c.assetPath){\r\n    return `${deckPath}/assets/${c.assetPath}`;\r\n  }else if(c.imageUrl){\r\n    return c.imageUrl;\r\n  }else{\r\n    return './assets/cards/sample.jpg';\r\n  }\r\n}\r\n\r\nconst createDeckFromData = (deckName, deckList, scoreMap) => {\r\n  let deckIdx = 0;\r\n  return deckList.map(c => ({\r\n    title: c.title || 'no title',\r\n    imageUrl: ThisModule.getCompleteCardUrl(c, `./packs/${deckName}`),\r\n    meta: ThisModule.parseMeta(c.meta, scoreMap),\r\n    deckIdx: deckIdx++\r\n  })).flat()\r\n};\r\n\r\n/* too lazy to make the cards stack in a pile right now */\r\nlet shifter = 0;\r\nconst getInitialPlacement = () => {\r\n  shifter += 2;\r\n  return {\r\n    x: 250 + shifter,\r\n    y: 200 + shifter\r\n  }\r\n}\r\n\r\nconst getRandomPositionOnStage = () => {\r\n  const wClamp = 200;\r\n  const hClamp = 150;\r\n\r\n  const w = window.innerWidth - (wClamp * 2);\r\n  const h = window.innerHeight - (hClamp * 2);\r\n\r\n  return {\r\n    x: wClamp + Math.floor(Math.random() * w),\r\n    y: hClamp + Math.floor(Math.random() * h),\r\n  }\r\n}\r\n\r\nconst filterDeckToWhatsLeft = (activeCards, deck, workOrder) => {\r\n  if(!workOrder) workOrder = [];\r\n\r\n  return deck.filter((dC,idx) => {\r\n    const inPlay = activeCards.find(aC => aC.deckIdx === dC.deckIdx) || workOrder.indexOf(dC.deckIdx) > -1;\r\n    return !inPlay;\r\n  });\r\n}\r\n\r\nconst getStartIdxForHand = hand => {\r\n  try{\r\n    if(!hand || hand.length === 0) return 0;\r\n    return hand[hand.length - 1].cardIdx + 1;\r\n  }catch(e){\r\n    console.error('couldnt get start index with hand', hand)\r\n    return 0;\r\n  }\r\n}\r\n\r\nconst produceDeckHand = (deck, hand, cardLayer) => {\r\n  const newHand = [];\r\n  const workOrder = [];\r\n  let startIdx = 0;\r\n  if(cardLayer === undefined){\r\n    cardLayer = 1;\r\n  }\r\n\r\n  /* this is stupid and complicated */\r\n  if(hand){\r\n    startIdx = getStartIdxForHand(hand);\r\n  }else{\r\n    hand = [];\r\n  }\r\n\r\n  for(let i = 0; i < deck.length; i++){\r\n    let newCard = ThisModule.produceCard((i + startIdx), deck, hand, workOrder, cardLayer++);\r\n    if(newCard){\r\n      workOrder.push(newCard.deckIdx);\r\n    }\r\n    newCard && newHand.push(newCard);\r\n  }\r\n  \r\n  return newHand;\r\n}\r\n\r\nconst produceHand = (cardCount, deck, hand, cardLayer) => {\r\n  const newHand = [];\r\n  const workOrder = [];\r\n  let startIdx = 0;\r\n  if(cardLayer === undefined){\r\n    cardLayer = 1;\r\n  }\r\n\r\n  /* this is stupid and complicated */\r\n  if(hand){\r\n    startIdx = getStartIdxForHand(hand);\r\n  }else{\r\n    hand = [];\r\n  }\r\n\r\n  for(let i = 0; i < cardCount; i++){\r\n    let newCard = ThisModule.produceCard((i + startIdx), deck, hand, workOrder, cardLayer++);\r\n    if(newCard){\r\n      workOrder.push(newCard.deckIdx);\r\n    }\r\n    newCard && newHand.push(newCard);\r\n  }\r\n  \r\n  return newHand;\r\n}\r\n\r\n/* some mutation going on here needs to get fixed */\r\n/* supports producing multiple cards outside of state, kinda sloppy */\r\nconst produceCard = (cardIdx, deck, hand, workOrder, topLayer) => {\r\n  let filteredDeck = ThisModule.filterDeckToWhatsLeft(hand, deck, workOrder);\r\n  if(!filteredDeck || filteredDeck.length === 0){\r\n    console.warn('the deck is empty!')\r\n    return null;\r\n  }\r\n\r\n  let randIdx = Math.floor(Math.random() * filteredDeck.length);\r\n  let deckCard = filteredDeck[randIdx];\r\n  let newPos = getInitialPlacement();\r\n\r\n  return {\r\n    cardIdx: cardIdx,\r\n    deckIdx: deckCard.deckIdx,\r\n    info: deckCard,\r\n    status: CARDSTATUS.HAND,\r\n    layer: topLayer,\r\n    position: newPos\r\n  }\r\n};\r\n\r\nconst getCardAtIdx = (cardData, cardIdx) => {\r\n  const card = cardData[cardIdx];\r\n  if(!card) return null;\r\n\r\n  return card;\r\n};\r\n\r\nexport default {\r\n  createDeckFromData: createDeckFromData,\r\n  parseMeta: parseMeta,\r\n  produceCard: produceCard,\r\n  getCardAtIdx: getCardAtIdx,\r\n  filterDeckToWhatsLeft: filterDeckToWhatsLeft,\r\n  produceHand: produceHand,\r\n  produceDeckHand: produceDeckHand,\r\n  getCompleteCardUrl: getCompleteCardUrl\r\n};\r\n","import ThisModule from './gamemaster';\r\nimport DeckMaker from './deckmaker';\r\n\r\nconst store = {\r\n  'rounds': [],\r\n  'cardPack': [],\r\n  'scoreMap': [],\r\n  'name': null\r\n};\r\n\r\nconst setRoundData = (roundData, roundIdx) => {\r\n  store.rounds = roundData;\r\n}\r\n\r\nconst setCardPackData = (cardPackData, scoreMap, cardPackName) => {\r\n  store.scoreMap = scoreMap;\r\n  store.name = cardPackName;\r\n\r\n  let deckIdx = 0;\r\n  store.cardPack = cardPackData.map(c => ({\r\n    id: c.id,\r\n    title: c.title || 'no title',\r\n    imageUrl: DeckMaker.getCompleteCardUrl(c, `./packs/${cardPackName}`),\r\n    meta: DeckMaker.parseMeta(c.meta, scoreMap),\r\n    deckIdx: deckIdx++\r\n  })).flat();\r\n}\r\n\r\n\r\nconst getRound = (roundIdx) => {\r\n  try{\r\n    // console.log('getting round', roundIdx, store.rounds)\r\n    return store.rounds[roundIdx];\r\n  }catch(e){\r\n    console.error('could not retrieve current round');\r\n  }\r\n  \r\n}\r\n\r\nconst getNumRounds = () => {\r\n  return store.rounds.length;\r\n}\r\n\r\nconst getAdjacentRoundIdx = (curIdx, change) => {\r\n  const nextIdx = curIdx + change;\r\n  if(nextIdx < 0){\r\n    console.log('round is below 0!');\r\n    return -1;\r\n  }\r\n\r\n  if(store.rounds.length > nextIdx){\r\n    return nextIdx;\r\n  }else{\r\n    console.log('no more rounds!');\r\n    return -1;\r\n  }\r\n}\r\n\r\nconst getRoundData = (roundIdx) => {\r\n  console.log('getRoundData', roundIdx, store.rounds)\r\n  try{\r\n    return {\r\n      idx: roundIdx,\r\n      targetScore: store.rounds[roundIdx].targetScore,\r\n      title: store.rounds[roundIdx].title,\r\n    }\r\n  }catch(e){\r\n    return {\r\n      idx: -1,\r\n      targetScore: 2000\r\n    }\r\n  }\r\n}\r\nconst getCardPack = () => {\r\n  return store.cardPack;\r\n}\r\n\r\nconst getRoundDeck = (roundIdx) => {\r\n  console.log('getRoundDeck');\r\n  if(isNaN(roundIdx)){\r\n    console.error('getRoundDeck missing valid roundIdx', roundIdx);\r\n    return [];\r\n  }\r\n  const rD = ThisModule.getRound(roundIdx);\r\n  if(rD.deck){\r\n    let roundCardIds = ThisModule.getRound(roundIdx).deck;\r\n    return ThisModule.getCardPack().filter(c => roundCardIds.indexOf(c.id) > -1);\r\n  }else{\r\n    //- if no custom deck defined, give the whole thing\r\n    return ThisModule.getCardPack();\r\n  }\r\n}\r\n\r\nconst getStore = () => store;\r\n\r\nexport default {\r\n  setRoundData: setRoundData,\r\n  setCardPackData: setCardPackData,\r\n  getAdjacentRoundIdx: getAdjacentRoundIdx,\r\n  getRound: getRound,\r\n  getRoundDeck: getRoundDeck,\r\n  getRoundData: getRoundData,\r\n  getStore: getStore,\r\n  getCardPack: getCardPack,\r\n  getNumRounds: getNumRounds\r\n};\r\n","import React, { useContext, useMemo } from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport { StoreContext } from '../../../store/context';\r\nimport { getColor } from '../../../themes/index';\r\nimport GameMaster from '../../../store/helpers/gamemaster';\r\n\r\nconst S = {};\r\n\r\nS.Container = styled.div`\r\n  /* padding:1rem; */\r\n`;\r\n\r\nS.Bg = styled.div`\r\n  position:absolute;\r\n  z-index:-1;\r\n  left:0;\r\n  top:0;\r\n  right:0;\r\n  bottom:0;\r\n`;\r\n\r\nS.TextArea = styled.div`\r\n  position:absolute;\r\n  padding-top: 1rem;\r\n  top:100%;\r\n  width:100%;\r\n  left:0;\r\n  text-align:center;\r\n  color:${getColor('white')}\r\n`;\r\n\r\n\r\nS.ZoneText = styled.p`\r\n\r\n`;\r\nS.CardCount = styled.p`\r\n  font-size:1rem;\r\n`;\r\n\r\nS.BasicButton = styled.div`\r\n  display:inline-block;\r\n  padding: .5rem 1.5rem;\r\n  margin:.5rem;\r\n  font-size: 1rem;\r\n  background-color: ${getColor('purple')};\r\n  border-radius: 1rem;\r\n  font-weight: bold;\r\n  cursor:pointer;\r\n\r\n  border: .5rem solid ${getColor('white')};\r\n  color:${getColor('white')};\r\n  &:first-child{\r\n    margin-top:0;\r\n  }\r\n\r\n  &:hover{\r\n    background-color: ${getColor('green')};\r\n    /* color:${getColor('blue')}; */\r\n    box-shadow: 0 0 1rem .2rem white;\r\n  }\r\n\r\n  ${p => p.isActive && css`\r\n    background-color: ${getColor('blue')};\r\n  `}\r\n`;\r\n\r\nfunction RoundButton({ roundIdx, onClick, isActive }){\r\n  return(\r\n    <S.BasicButton isActive={isActive} onClick={() => onClick(roundIdx)} role=\"button\">\r\n      {`${roundIdx + 1}`}\r\n    </S.BasicButton>\r\n  )\r\n}\r\n\r\nfunction RoundZone() {\r\n  const { roundData, deck, hand, actions } = useContext(StoreContext);\r\n\r\n  const renderRounds = (count) => {\r\n    let buttons = [];\r\n    for(let i = 0; i < count; i++){\r\n      buttons.push(\r\n        <RoundButton \r\n          key={i}\r\n          roundIdx={i} \r\n          isActive={roundData.idx === i}\r\n          onClick={() => actions.setRound(i)} \r\n        />\r\n      );\r\n    }\r\n    return buttons;\r\n  }\r\n\r\n  const numCardsInDrawPile = useMemo(() => \r\n    deck.length - hand.length, \r\n    [ deck.length, hand.length ]\r\n  );\r\n\r\n  return (\r\n    <S.Container >\r\n      <S.BasicButton onClick={() => actions.prevRound()} role=\"button\">\r\n        {'-'}\r\n      </S.BasicButton>\r\n      { renderRounds(GameMaster.getNumRounds()) }\r\n      <S.BasicButton onClick={() => actions.nextRound()} role=\"button\">\r\n        {'+'}\r\n      </S.BasicButton>\r\n      <S.TextArea>\r\n        <S.ZoneText>{`Round: ${roundData.idx + 1}: \"${roundData.title}\"`}</S.ZoneText>\r\n        <S.CardCount>{`${numCardsInDrawPile} cards left`}</S.CardCount>\r\n      </S.TextArea>\r\n      <S.Bg />\r\n    </S.Container>\r\n  );\r\n}\r\n\r\nexport default RoundZone;\r\n","import React, { useContext, useMemo } from 'react';\nimport styled, { css } from 'styled-components';\nimport { StoreContext } from '../../../store/context';\nimport MetaHelper from '../../../store/helpers/meta';\nimport { getColor } from '../../../themes/index';\n\nconst S = {};\n\nS.Container = styled.div`\n  padding-right:11rem;\n  padding-top:10rem;\n  font-size:1rem;\n`;\n\n\nS.Bg = styled.div`\n  position:absolute;\n  left:0;\n  top:0;\n  right:0;\n  bottom:0;\n  border: 2rem solid ${getColor('white')};\n  background-color:${getColor('blue')};\n  border-radius: 50%;\n  z-index:-1;\n\n  &:hover{\n    box-shadow: 0 0 1rem .2rem ${getColor('white')};\n  }\n`;\n\n\nS.ScoreGroup = styled.div`\n  text-align:right;\n`;\n\nS.TotalScore = styled.div`\n  >p{\n    &:nth-child(1){\n      font-size:2.5rem;\n      color:${getColor('white')};\n    }\n\n    /* the score  */\n    &:nth-child(2){\n      font-size: 5rem;\n      margin-top: -2.5rem;\n      margin-bottom: -1.5rem;\n      color:${getColor('ui_blue')};\n    }\n  }\n`;\n\nS.TargetScore = styled.div`\n  >p{\n    &:nth-child(1){\n      font-size:1.5rem;\n      color:${getColor('white')};\n    }\n\n    /* the score  */\n    &:nth-child(2){\n      font-size: 3rem;\n      margin-top: -1.5rem;\n      color:${getColor('ui_orange')};\n    }\n  }\n`;\n\nS.SubScore = styled.div`\n  >p{\n    /* label */\n    &:nth-child(1){\n      color:white;\n    }\n    /* the score  */\n    &:nth-child(2){\n      font-size: 2rem;\n      color:${getColor('blue')};\n    }\n  }\n`;\n\nfunction InfoZone() {\n  const { stacks, hand, roundData } = useContext(StoreContext);\n  const completeStacks = useMemo(() => \n    MetaHelper.calcCompleteStacks(stacks, hand),\n    [ stacks, hand ]\n  );\n\n  const totalScore = useMemo(() => \n    MetaHelper.calcTotalScore(completeStacks), \n    [ completeStacks ]\n  );\n  \n  const ppcScore = useMemo(() => \n    MetaHelper.calcSpcScore(totalScore, hand.length), \n    [ totalScore, hand.length ]\n  );\n\n  return (\n    <S.Container >\n      <S.ScoreGroup>\n        <S.TotalScore>\n          <p>{'TOTAL'}</p>\n          <p>{totalScore}</p>\n        </S.TotalScore>\n        <S.TargetScore>\n          <p>{'TARGET'}</p>\n          <p>{roundData.targetScore}</p>\n        </S.TargetScore>\n      </S.ScoreGroup>\n      <S.Bg/>\n    </S.Container>\n  );\n}\n\nexport default InfoZone;\n","import React, { useContext, useCallback, useEffect, useMemo, useState } from 'react';\r\nimport styled from 'styled-components';\r\nimport { StoreContext } from '../../store/context';\r\nimport ActiveCard from '../../components/card/active-card';\r\nimport { getColor } from '../../themes/index';\r\nimport DrawZone from './components/draw-zone';\r\nimport DropZone from './components/drop-zone';\r\nimport HandZone from './components/hand-zone';\r\nimport RoundZone from './components/round-zone';\r\nimport InfoZone from './components/info-zone';\r\nimport { CARDSTATUS } from '../../utils/constants';\r\n\r\nimport useDebounce from '../../utils/use-debounce';\r\n\r\n\r\nconst S = {};\r\nS.Board = styled.div`\r\n  position:absolute;\r\n  top:0;\r\n  left:0;\r\n  right:0;\r\n  bottom:0;\r\n  text-align:center;\r\n  z-index:2;\r\n`;\r\n\r\nS.PlayArea = styled.div`\r\n  position:relative;\r\n  width:100%;\r\n  height:100%;\r\n  overflow:hidden;\r\n`;\r\n\r\nS.DrawZone = styled.div`\r\n  position:absolute;\r\n  z-index:99999999;\r\n  top:1rem;\r\n  left:1rem;\r\n`;\r\n\r\nS.RoundZone = styled.div`\r\n  position:absolute;\r\n  z-index:99999999;\r\n  top:1rem;\r\n  left:16rem;\r\n  right:20rem;\r\n`;\r\n\r\nS.InfoZone = styled.div`\r\n  position:absolute;\r\n  z-index:99999999;\r\n  top:-12rem;\r\n  right:-10rem;\r\n  width: 30rem;\r\n  height: 30rem;\r\n  pointer-events:none;\r\n`;\r\n\r\nS.StackInfoZone = styled.div`\r\n  position:absolute;\r\n  z-index:1;\r\n  bottom: 0rem;\r\n  right: 0rem;\r\n  width: 46rem;\r\n  height: 30rem;\r\n`;\r\n\r\nS.DiscardZone = styled.div`\r\n  position:absolute;\r\n  bottom:0rem;\r\n  left:0rem;\r\n  width: 100%;\r\n  height: 13rem;\r\n`;\r\n\r\nS.Bg = styled.div`\r\n  position: absolute;\r\n  top:0;\r\n  left:0;\r\n  background-color: ${getColor('black')};\r\n  width:100%;\r\n  height:100%;\r\n  z-index:-9999999;\r\n`;\r\n\r\nS.BgImage = styled.img`\r\n  width: 2000px;\r\n  top:0;\r\n  left:0;\r\n`;\r\n\r\nS.CardContainer = styled.div``;\r\n\r\nS.HeldCardContainer = styled.div`\r\n  position:absolute;\r\n  left:0;\r\n  top:0;\r\n`;\r\n\r\nfunction Board() {\r\n  const { actions, hand, dataLoaded } = useContext(StoreContext);\r\n  const [ mouseCoords, setMouseCoords ] = useState(null);\r\n\r\n  /* unhovering stack makes the highlight go away */\r\n  const onBgMouseOver = useCallback(() => {\r\n    actions.setFocusedStackIdx(-1);\r\n    actions.setFocusedCardIdx(-1);\r\n  }, [ actions.setFocusedStackIdx, actions.setFocusedCardIdx ]);\r\n\r\n  useEffect(() => {\r\n    const urlParams = new URLSearchParams(window.location.search);\r\n    const packUrl = urlParams.get('pack');\r\n    if(packUrl){\r\n      actions.loadData(packUrl);\r\n    }else{\r\n      actions.loadData();\r\n    }\r\n  }, [ actions.loadData ]);\r\n\r\n  const cardsOnTable = useMemo(() => \r\n    hand.filter(h => h.status > CARDSTATUS.HAND && h.status < CARDSTATUS.DISCARDED),\r\n    [ hand ]\r\n  );\r\n  const debouncedCoords = useDebounce(mouseCoords, 50);\r\n\r\n  useEffect(() => {\r\n    actions.setMouseCoords(debouncedCoords);\r\n  }, [ debouncedCoords, actions.setMouseCoords ]);       \r\n\r\n  if(!dataLoaded){\r\n    return <h1>{'Loading...'}</h1>\r\n  }\r\n\r\n  return (\r\n    <S.Board onMouseMove={e => setMouseCoords({x: e.clientX, y: e.clientY})}>\r\n      <HandZone />\r\n      <S.DrawZone>\r\n        <DrawZone />\r\n      </S.DrawZone>\r\n      <S.RoundZone>\r\n        <RoundZone />\r\n      </S.RoundZone>\r\n      <S.InfoZone>\r\n        <p>{'info'}</p>\r\n        <InfoZone />\r\n      </S.InfoZone>\r\n      <S.DiscardZone>\r\n        <DropZone action={'discard'} />\r\n      </S.DiscardZone>\r\n\r\n      <S.CardContainer id=\"cc\">\r\n        {cardsOnTable.map((c, idx) => \r\n          <ActiveCard data={c} key={c.cardIdx} />\r\n        )}\r\n      </S.CardContainer>\r\n      \r\n      <S.Bg onMouseOver={onBgMouseOver}>\r\n        <S.BgImage src={'./assets/bg/space.jpg' } />\r\n      </S.Bg>\r\n    </S.Board>\r\n  );\r\n}\r\n\r\nexport default Board;\r\n","//- example from https://stackoverflow.com/questions/54666401/how-to-use-throttle-or-debounce-with-react-hook\r\nimport { useState, useEffect } from 'react';\r\n\r\nexport default (value, timeout) => {\r\n  const [state, setState] = useState(value);\r\n\r\n  useEffect(() => {\r\n    const handler = setTimeout(() => setState(value), timeout);\r\n\r\n    return () => clearTimeout(handler);\r\n  }, [value, timeout]);\r\n\r\n  return state;\r\n}","const loadData = (url, callback) => {\r\n  console.log(`loading data ${url}...`);\r\n  var xhr = new XMLHttpRequest();\r\n  xhr.open('GET', url);\r\n  xhr.send(null);\r\n\r\n  xhr.onreadystatechange = function () {\r\n    var DONE = 4; // readyState 4 means the request is done.\r\n    var OK = 200; // status 200 is a successful return.\r\n    try{\r\n      if (xhr.readyState === DONE) {\r\n        if (xhr.status === OK) {\r\n          console.log(`...data was loaded!`);\r\n          //- the response is just text, so parse it into a JSON object\r\n          var gameData = JSON.parse(xhr.responseText);\r\n          callback(gameData);\r\n        } else {\r\n          console.error(`Error loading data from ${url}. Perhaps the file is not found?: `, xhr.status); // An error occurred during the request.\r\n        }\r\n      }\r\n    }catch(e){\r\n      console.error(`Error loading data from ${url}. Perhaps the JSON is malformed?`, e);\r\n    }\r\n  };\r\n}\r\n\r\nexport default {\r\n  loadData: loadData\r\n};\r\n","import React, { useState, useCallback } from 'react';\r\nimport { StoreContext } from './context';\r\nimport StackHelper from './helpers/stack';\r\nimport DeckMaker from './helpers/deckmaker';\r\nimport GameMaster from './helpers/gamemaster';\r\nimport DataHelper from './helpers/data';\r\nimport { CARDSTATUS } from '../utils/constants';\r\n\r\nlet topLayer = 0;\r\n\r\n// const DEFAULT_PACK = 'sample';\r\nconst DEFAULT_PACK = 'traditional';\r\n\r\n\r\nfunction Store({children}) {\r\n  const [ holdingIdx, setHoldingIdx ] = useState(-1);\r\n  const [ focusedStackIdx, setFocusedStackIdx ] = useState(-1);\r\n  const [ tooltipCoords, setTooltipCoords ] = useState(null);\r\n  const [ mouseCoords, setMouseCoords ] = useState(null);\r\n  const [ focusedCardIdx, setFocusedCardIdx ] = useState(-1);\r\n  const [ hand, setHandRaw ] = useState([]);\r\n  const [ deck, setDeck ] = useState([]);\r\n  const [ zones, setZones ] = useState([]);\r\n  const [ stacks, setStacks ] = useState([]);\r\n  const [ dataLoaded, setDataLoaded ] = useState(false);\r\n  const [ roundData, setRoundData ] = useState({});\r\n\r\n  const setAllRoundData =  useCallback(newRoundIdx => {\r\n    setRoundData(GameMaster.getRoundData(newRoundIdx));\r\n  }, [ setRoundData ]);\r\n\r\n  const loadData = useCallback(packName => {\r\n    packName = packName || DEFAULT_PACK;\r\n\r\n    const dataUrl = `./packs/${packName}/data.json`;\r\n    // console.log('loading data from ', dataUrl);\r\n    DataHelper.loadData(dataUrl, (data) => {\r\n      try{\r\n        console.log('heres your data', data);\r\n        GameMaster.setRoundData(data.pack.rounds);\r\n        GameMaster.setCardPackData(data.pack.cards, data.pack.scoreMap, data.pack.name);\r\n\r\n        const roundIdx = 0;\r\n        setAllRoundData(roundIdx);\r\n        setDeck(GameMaster.getRoundDeck(roundIdx));\r\n        setDataLoaded(true);\r\n      }\r\n      catch(e){\r\n        console.error('problem intializing data', e)\r\n      }\r\n    });\r\n  }, [ setDataLoaded, setAllRoundData ]);\r\n\r\n  const setHand = useCallback((hand, responsibleIdx) => {\r\n    // console.log('setHand', responsibleIdx);\r\n    const stacks = StackHelper.calcStacks(hand);\r\n    setStacks(stacks);\r\n    // console.log('setStacks', stacks)\r\n    \r\n    const newHand = hand.map(c => ({\r\n      ...c,\r\n      stackIdx: stacks.findIndex(s => s.indexOf(c.cardIdx) > -1)\r\n    }));\r\n\r\n    setHandRaw(newHand);\r\n    if(responsibleIdx > -1){\r\n      setFocusedStackIdx(newHand.find(c => c.cardIdx === responsibleIdx).stackIdx);\r\n    }\r\n  }, [ setHandRaw, setStacks, setFocusedStackIdx ]);\r\n\r\n  const discardCard = useCallback(cardIdx => {\r\n    setHand(hand.filter(h => h.cardIdx !== cardIdx));\r\n  }, [ setHand, hand ]);\r\n\r\n  const dealHand = useCallback(cardLimit => {\r\n    topLayer = 1;\r\n    const newHand = DeckMaker.produceHand(deck.length - (cardLimit || 0), GameMaster.getRoundDeck(roundData.idx), [], topLayer);\r\n\r\n    topLayer += newHand.length;\r\n    setHand(newHand);\r\n  }, [ setHand, roundData.idx, deck ]);\r\n\r\n  const dealCard = useCallback(cardCount => {\r\n    const newHand = DeckMaker.produceHand(cardCount, GameMaster.getRoundDeck(roundData.idx), hand, topLayer);\r\n\r\n    topLayer += newHand.length;\r\n    setHand(hand.concat(newHand));\r\n  }, [ setHand, hand, roundData.idx ]);\r\n\r\n  const discardHand = useCallback(() => {\r\n    topLayer = 1;\r\n    setHand([]);\r\n  }, [ setHand ]);\r\n\r\n  const discardRandomCard = useCallback(() => {\r\n    if(hand.length > 0){\r\n      const randHandIdx = Math.floor(Math.random() * hand.length);\r\n      discardCard(hand[randHandIdx].cardIdx);\r\n    }\r\n  }, [ discardCard, hand ]);\r\n  \r\n  /* this zone junk needs some work */\r\n  const setZone = useCallback((zoneId, bounds) => {\r\n    if(zones.find(z => z.id === zoneId)){\r\n      setZones(zones.map(z => {\r\n        if(z.id === zoneId){\r\n          return {\r\n            ...z,\r\n            bounds: {\r\n              top: bounds.top,\r\n              left: bounds.left,\r\n              right: bounds.right,\r\n              bottom: bounds.bottom\r\n            }\r\n          }\r\n        }else{\r\n          return z;\r\n        }\r\n      }));\r\n    }else{\r\n      setZones(zones.concat([\r\n        {\r\n          id:zoneId,\r\n          bounds: {\r\n            top: bounds.top,\r\n            left: bounds.left,\r\n            right: bounds.right,\r\n            bottom: bounds.bottom\r\n          }\r\n        }\r\n      ]))\r\n    }\r\n  }, [ zones, setZones ]);\r\n\r\n  const getZonesAtPosition = (position, zones) => {\r\n    return zones.filter(z => {\r\n      return (\r\n        (position.x > z.bounds.left && position.x < z.bounds.right)\r\n        && (position.y > z.bounds.top && position.y < z.bounds.bottom)\r\n      );\r\n    })\r\n  }\r\n\r\n  const nextRound = useCallback(() => {\r\n    const foundIdx = GameMaster.getAdjacentRoundIdx(roundData.idx, 1);\r\n    if(foundIdx > -1){\r\n      discardHand();\r\n      setAllRoundData(foundIdx);\r\n      setDeck(GameMaster.getRoundDeck(foundIdx));\r\n    }else{\r\n      console.log('nextRound, end of rounds!');\r\n    }\r\n  }, [ roundData.idx, setAllRoundData, discardHand ]);\r\n  \r\n  const prevRound = useCallback(() => {\r\n    const foundIdx = GameMaster.getAdjacentRoundIdx(roundData.idx, -1);\r\n    if(foundIdx > -1){\r\n      discardHand();\r\n      setAllRoundData(foundIdx);\r\n      setDeck(GameMaster.getRoundDeck(foundIdx))\r\n    }else{\r\n      console.log('nextRound, end of rounds!');\r\n    }\r\n  }, [ roundData.idx, setAllRoundData, discardHand ]);\r\n\r\n  const setRound = useCallback(roundIdx => {\r\n    const foundRound = GameMaster.getRound(roundIdx);\r\n    if(foundRound){\r\n      discardHand();\r\n      setAllRoundData(roundIdx);\r\n      setDeck(GameMaster.getRoundDeck(roundIdx))\r\n    }else{\r\n      console.log(`setRound, roundIdx \"${roundIdx}\" not found`);\r\n    }\r\n  }, [ setAllRoundData, discardHand ]);\r\n\r\n  const dropCardStatus = (status, location) => {\r\n    if(CARDSTATUS[location]){\r\n      return CARDSTATUS[location];\r\n    };\r\n\r\n    if(status === CARDSTATUS.HAND_HOLDING){\r\n      return CARDSTATUS.HAND;\r\n    }else if(status === CARDSTATUS.TABLE_HOLDING){\r\n      return CARDSTATUS.TABLE;\r\n    }else{\r\n      return status;\r\n    }\r\n  }\r\n\r\n  const holdCardStatus = status => {\r\n    if(status === CARDSTATUS.HAND){\r\n      return CARDSTATUS.HAND_HOLDING;\r\n      // return CARDSTATUS.TABLE;\r\n    }else if(status === CARDSTATUS.TABLE){\r\n      return CARDSTATUS.TABLE_HOLDING;\r\n    }else{\r\n      return status;\r\n    }\r\n  }\r\n\r\n  const holdCard = useCallback((cardIdx, position) => {\r\n    setHoldingIdx(cardIdx);\r\n\r\n    setHand(hand.map(c => {\r\n      if(c.cardIdx === cardIdx){\r\n        return {\r\n          ...c,\r\n          status:holdCardStatus(c.status),\r\n          position: position ? position : c.position\r\n        }\r\n      }else{\r\n        const droppedStatus = dropCardStatus(c.status);\r\n        if(c.status !== droppedStatus){\r\n          return {\r\n            ...c,\r\n            status: droppedStatus\r\n          }\r\n        }else{\r\n          return c;\r\n        }\r\n      }\r\n    }));\r\n  }, [ setHoldingIdx, hand, setHand ]);\r\n\r\n  const placeCardInHand = useCallback(cardIdx => {\r\n    setHand(hand.map(c => {\r\n      if(c.cardIdx === cardIdx){\r\n        return {\r\n          ...c,\r\n          status:CARDSTATUS.HAND\r\n        }\r\n      }\r\n      return c;\r\n    }));\r\n  }, [ setHoldingIdx, hand, setHand ]);\r\n\r\n  const setFocusedStackIdxHelper = useCallback((focusedIdx, tooltipCoords) => {\r\n    setFocusedStackIdx(focusedIdx);\r\n    if(tooltipCoords){\r\n      setTooltipCoords(tooltipCoords);\r\n    }else{\r\n      setTooltipCoords(null);\r\n    }\r\n  }, [ setFocusedStackIdx, setTooltipCoords ]);\r\n\r\n  /*\r\n  const dropCard = useCallback((cardIdx, location, newPosition) => {\r\n    // console.log('drop ', cardIdx);\r\n    setHoldingIdx(-1);\r\n    if(cardIdx === holdingIdx){\r\n      setHoldingIdx(-1);\r\n    }\r\n\r\n    setHand(hand.map(c => {\r\n      if(c.cardIdx === cardIdx){\r\n        return {\r\n          ...c,\r\n          status:dropCardStatus(c.status, location),\r\n          layer: topLayer++,\r\n          position: newPosition ? {\r\n            x: newPosition.x,\r\n            y: newPosition.y\r\n          } : c.position\r\n        }\r\n      }\r\n      \r\n      return c;\r\n    }));\r\n  }, [ setHoldingIdx, hand, setHand, holdingIdx ]);\r\n  */\r\n\r\n  const dropCard = useCallback((cardIdx, location, newPosition) => {\r\n    // console.log('drop ', cardIdx);\r\n    setHoldingIdx(-1);\r\n    if(cardIdx === holdingIdx){\r\n      setHoldingIdx(-1);\r\n    }\r\n\r\n    const foundCard = hand.find(c => c.cardIdx === cardIdx);\r\n    if(foundCard && location === 'TABLE'){\r\n      let activeZones = [];\r\n      if(foundCard){\r\n        activeZones = getZonesAtPosition(newPosition, zones);\r\n      }\r\n\r\n      if(activeZones.find(az => az.id === 'hand')){\r\n        placeCardInHand(cardIdx);\r\n\r\n        return;\r\n      }\r\n    }\r\n\r\n    setHand(hand.map(c => {\r\n      if(c.cardIdx === cardIdx){\r\n        return {\r\n          ...c,\r\n          status:dropCardStatus(c.status, location),\r\n          layer: topLayer++,\r\n          position: newPosition ? {\r\n            x: newPosition.x,\r\n            y: newPosition.y\r\n          } : c.position\r\n        }\r\n      }\r\n      \r\n      return c;\r\n    }));\r\n  }, [ setHoldingIdx, hand, setHand, holdingIdx, zones, placeCardInHand ]);\r\n\r\n  return (\r\n    <StoreContext.Provider \r\n      value={{\r\n        dataLoaded: dataLoaded,\r\n        deck: deck,\r\n        hand: hand,\r\n        stacks: stacks,\r\n        zones: zones,\r\n        roundData: roundData,\r\n        holdingIdx: holdingIdx,\r\n        focusedStackIdx: focusedStackIdx,\r\n        focusedCardIdx: focusedCardIdx,\r\n        tooltipCoords: tooltipCoords,\r\n        mouseCoords: mouseCoords,\r\n        actions:{\r\n          nextRound: nextRound,\r\n          prevRound: prevRound,\r\n          setRound: setRound,\r\n          dealHand: dealHand,\r\n          dealCard: dealCard,\r\n          discardCard: discardCard,\r\n          discardRandomCard: discardRandomCard,\r\n          discardHand: discardHand,\r\n          loadData: loadData,\r\n          setZone: setZone,\r\n          setHoldingIdx: setHoldingIdx,\r\n          setFocusedStackIdx: setFocusedStackIdxHelper,\r\n          setFocusedCardIdx: setFocusedCardIdx,\r\n          setMouseCoords: setMouseCoords,\r\n          holdCard: holdCard,\r\n          dropCard: dropCard,\r\n          placeCardInHand: placeCardInHand,\r\n        }\r\n      }}>\r\n        {children}\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\nexport default Store;\r\n","import React, { useContext, useMemo } from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport {  getColor } from '../../themes/index';\r\nimport { StoreContext } from '../../store/context';\r\nimport MetaHelper from '../../store/helpers/meta';\r\nimport StackHelper from '../../store/helpers/stack';\r\n\r\nconst S = {};\r\n\r\nS.Tooltips = styled.div`\r\n  position:fixed;\r\n  pointer-events:none;\r\n  top:0;\r\n  left:0;\r\n  z-index:3;\r\n`;\r\n\r\nS.Tooltip = styled.div`\r\n  position:absolute;\r\n  transition: top .2s, left: .2s;\r\n`;\r\n\r\nS.StackEntry = styled.div`\r\n  opacity:0;\r\n  font-size:1.5rem;\r\n\r\n  ${p => p.isActive && css`\r\n    opacity:1;\r\n  `}\r\n\r\n  background-color:black;\r\n  border:5px solid white;\r\n  border-radius:2rem;\r\n  padding:.5rem 1rem;\r\n  padding-top:0;\r\n  min-width: 20rem;\r\n\r\n  ul{\r\n    list-style:none;\r\n\t  margin-left: 0;\r\n\t  padding-left: 0;\r\n  }\r\n`;\r\n\r\nS.MetaLine = styled.li`\r\n  color:white;\r\n  display:flex;\r\n`;\r\nS.MetaTag = styled.div`\r\n  border:2px solid white;\r\n  background-color: ${getColor('blue')};\r\n  border-radius:1rem;\r\n  padding:1rem;\r\n`;\r\nS.MetaScore = styled.div`\r\n  flex: 1 0 20%;\r\n  text-align:right;\r\n`;\r\nS.MetaTagLabel = styled.p`\r\n\r\n`;\r\nS.MetaTagValue = styled.p`\r\n  font-size:1.25rem;\r\n`;\r\nS.StackTotal = styled.div`\r\n  color:white;\r\n`;\r\n\r\n\r\nfunction MetaLine({ data }){\r\n  return (\r\n    <S.MetaLine>\r\n      <S.MetaTag>\r\n        <S.MetaTagLabel>{`${data.tag}:`}</S.MetaTagLabel>\r\n        <S.MetaTagValue>{`${data.value.toString()}`}</S.MetaTagValue>\r\n      </S.MetaTag>\r\n      <S.MetaScore>\r\n        <p>{data.score}</p>\r\n      </S.MetaScore>\r\n    </S.MetaLine>\r\n  );\r\n}\r\n\r\nfunction StackEntry({ stack }) {\r\n  if(stack){\r\n    return (\r\n      <S.StackEntry isActive={!!stack}>\r\n        {stack.meta.length > 0 ? (\r\n          <ul>\r\n            { stack.meta.map((m, i) => <MetaLine key={i} data={m} />) }\r\n          </ul>\r\n        ):(\r\n          <ul>\r\n            <li>{'no matching tags'}</li>\r\n          </ul>\r\n        )}\r\n        <S.StackTotal>\r\n          <span>{stack.count}</span>\r\n          <span>{` cards x `}</span>\r\n          <span>{stack.subScore}</span>\r\n          <span>{'= '}</span>\r\n          <span>{stack.score}</span>\r\n        </S.StackTotal>\r\n      </S.StackEntry>\r\n    )\r\n  } else{\r\n    return (\r\n      <S.StackEntry isActive={false}>\r\n      </S.StackEntry>\r\n    );\r\n  }\r\n}\r\n\r\n\r\nfunction Tooltips({ data }) {\r\n  const { mouseCoords, stacks, hand, focusedStackIdx } = useContext(StoreContext);\r\n\r\n  const tooltipCss = useMemo(() => {\r\n    if(mouseCoords){\r\n      return {\r\n        left: mouseCoords.x,\r\n        top: mouseCoords.y\r\n      }\r\n    }else{\r\n      return null;\r\n    }\r\n  }, [ mouseCoords ]);\r\n\r\n  const completeStacks = useMemo(() => \r\n    MetaHelper.calcCompleteStacks(stacks, hand),\r\n    [ stacks, hand ]\r\n  );\r\n  const stack = useMemo(() => \r\n    completeStacks.find(stack => stack.idx === focusedStackIdx),\r\n    [ completeStacks, focusedStackIdx ]\r\n  );\r\n\r\n  return (\r\n    <S.Tooltips>\r\n      <S.Tooltip style={tooltipCss} isActive={!!stack}>\r\n        <StackEntry stack={stack} />\r\n      </S.Tooltip>\r\n    </S.Tooltips>\r\n  );\r\n}\r\n\r\nexport default Tooltips;\r\n","import React, { useContext, useEffect } from 'react';\nimport Board from '../board';\nimport GameMaster from '../../store/helpers/gamemaster';\nimport DeckMaker from '../../store/helpers/deckmaker';\nimport Store from '../../store';\nimport styled from 'styled-components';\nimport Tooltips from '../../components/ui/tooltips';\n\nconst S = {};\nS.Container = styled.div`\n  position:absolute;\n  width:100%;\n  height:100%;\n  overflow:hidden;\n`;\n\nwindow.gm = GameMaster;\nwindow.dm = DeckMaker;\n\nfunction Main() {\n  return (\n    <S.Container>\n      <Store>\n        <Tooltips />\n        <Board />\n      </Store>\n    </S.Container>\n  );\n}\n\nexport default Main;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './themes/theme.scss';\nimport Main from './containers/main';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<Main />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}