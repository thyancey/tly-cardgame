{"version":3,"sources":["containers/board/components/stack-console.js","themes/index.js","components/card/card.js","components/card/active-card.js","containers/board/components/draw-zone.js","containers/board/components/drop-zone.js","containers/board/components/stack-zone.js","components/card/hand-card.js","containers/board/components/hand-zone.js","store/helpers/deckmaker.js","store/helpers/gamemaster.js","containers/board/components/round-zone.js","containers/board/components/info-zone.js","containers/board/index.js","store/helpers/data.js","store/index.js","containers/main/index.js","serviceWorker.js","index.js","utils/constants.js","store/context.js","store/helpers/stack.js","store/helpers/meta.js"],"names":["S","Container","styled","div","Bg","BgShape","getColor","BgText","img","StackEntryDivider","hr","StackEntryFooter","SubScore","SubScoreValue","span","SubScoreMultiplier","TotalScore","StackPreview","StackPreviewCenterer","ul","StackMeta","NoMeta","li","MetaLine","MetaLineLeft","MetaLineRight","MetaTag","p","MetaValue","StackEntry","StackDetailsBg","Cards","Details","Total","timer","data","tag","value","toString","score","label","idx","count","cardIdxs","cards","subScore","meta","isShowing","stackBounds","stackIdxs","forEach","element","global","document","querySelector","children","rect","getBoundingClientRect","upperLeft","x","left","y","top","lowerRight","right","bottom","getStackBounds","cssBox","style","className","length","map","m","i","key","StackConsole","useContext","StoreContext","stacks","hand","focusedStackIdx","useState","setIsShowing","completeStacks","useMemo","MetaHelper","calcCompleteStacks","stack","find","startTimeout","callback","window","clearTimeout","setTimeout","useEffect","id","cardDetails","StackHelper","getStackLabel","colorId","store","color","getShadow","shadowId","shadow","breakpoints","black","grey","grey_light","white","blue","green","yellow","orange","purple","pink","ui_blue","ui_orange","ui_yellow","ui_green","z1","z2","z3","headerHeight","menuWidth","mixins","mobile_tiny","mobile_medium","mobile_large","tablet","desktop","Card","theme","depth","isDragging","css","inHand","InnerCard","stackStyle","Background","DebugStatus","AbstractCard","onMouseDown","onMouseOver","position","cardRef","dragPosition","cardIdx","e","stackIdx","layer","ref","getCardStatusLabel","status","src","info","imageUrl","draggable","ActiveCard","actions","activeListener","state","setState","useRef","useCallback","setFocusedCardIdx","setFocusedStackIdx","clientX","clientY","holdCard","onMouseDraggingCard","onMouseDroppedCard","dropCard","current","addEventListener","removeEventListener","initialized","restingPosition","CARDSTATUS","HAND","BasicButton","ZoneText","DrawZone","onClick","dealHand","role","dealCard","discardHand","discardRandomCard","DropZone","props","zoneRef","React","createRef","onWindowResize","bind","this","context","setZone","Component","contextType","StackEntryBody","HandCard","Hand","cardsInHand","filter","h","c","handPosition","shifter","getStartIdxForHand","console","error","createDeckFromData","deckName","deckList","scoreMap","deckIdx","title","ThisModule","getCompleteCardUrl","parseMeta","flat","metaArray","type","produceCard","deck","workOrder","topLayer","filteredDeck","filterDeckToWhatsLeft","warn","deckCard","Math","floor","random","newPos","getCardAtIdx","cardData","card","activeCards","dC","aC","indexOf","produceHand","cardCount","cardLayer","newHand","startIdx","undefined","newCard","push","produceDeckHand","deckPath","assetPath","setRoundData","roundData","roundIdx","rounds","setCardPackData","cardPackData","cardPackName","name","cardPack","DeckMaker","getAdjacentRoundIdx","curIdx","change","nextIdx","log","getRound","getRoundDeck","isNaN","roundCardIds","getCardPack","getRoundData","targetScore","getStore","getNumRounds","RoundButton","isActive","TextArea","CardCount","RoundZone","numCardsInDrawPile","prevRound","buttons","setRound","renderRounds","GameMaster","nextRound","ScoreGroup","TargetScore","InfoZone","totalScore","calcTotalScore","calcSpcScore","Board","PlayArea","StackInfoZone","DiscardZone","BgImage","CardContainer","HeldCardContainer","dataLoaded","onBgMouseOver","packUrl","URLSearchParams","location","search","get","loadData","cardsOnTable","DISCARDED","action","url","xhr","XMLHttpRequest","open","send","onreadystatechange","readyState","gameData","JSON","parse","responseText","Store","holdingIdx","setHoldingIdx","focusedCardIdx","setHandRaw","setDeck","zones","setZones","setStacks","setDataLoaded","setAllRoundData","newRoundIdx","packName","dataUrl","DataHelper","pack","setHand","responsibleIdx","calcStacks","findIndex","s","discardCard","cardLimit","concat","randHandIdx","zoneId","bounds","z","foundIdx","dropCardStatus","HAND_HOLDING","TABLE_HOLDING","TABLE","droppedStatus","placeCardInHand","newPosition","foundCard","activeZones","getZonesAtPosition","az","Provider","gm","dm","Main","Boolean","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message","statusIdx","Object","keys","statusKey","createContext","BOUND_OFFSET","ALPHA","isThisInThat","aA","aB","a","mergeArrays","b","produceBounds","createBoundedHand","doesOverlap","bA","bB","getGroupPairs","boundedHand","groupPairs","createRawStacks","givenGroupPairs","remainingGroupPairs","slice","matchObj","mutateForGroupPairs","findStackWithMatch","groupPair","matchFound","foundStackIdx","splice","getStackColor","calcStackMeta","produceCards","stackMeta","invalidatedTags","cMeta","metaInfo","oldMeta","sM","checkTag","some","t","getSortedCardDetails","cardStack","cIdx","cdata","sort","reduce","curStack","handLength","round","sIdx"],"mappings":"omIASA,IAAMA,EAAI,GAEVA,EAAEC,UAAYC,IAAOC,IAArB,IAEI,GACA,GACA,GACA,GACA,IAkBJH,EAAEI,GAAKF,IAAOC,IAAd,KASAH,EAAEK,QAAUH,IAAOC,IAAnB,IAMuBG,YAAS,SACXA,YAAS,QAIGA,YAAS,UAI1CN,EAAEO,OAASL,IAAOM,IAAlB,KAYAR,EAAES,kBAAoBP,IAAOQ,GAA7B,IACkBJ,YAAS,UAM3BN,EAAEW,iBAAmBT,IAAOC,IAA5B,KAYAH,EAAEY,SAAWV,IAAOC,IAApB,KAIAH,EAAEa,cAAgBX,IAAOY,KAAzB,IAEWR,YAAS,YAGpBN,EAAEe,mBAAqBb,IAAOC,IAA9B,IAGaG,YAAS,YAGPA,YAAS,UAKxBN,EAAEgB,WAAad,IAAOC,IAAtB,IASeG,YAAS,SAKTA,YAAS,aACSA,YAAS,UAK1CN,EAAEiB,aAAef,IAAOC,IAAxB,KASAH,EAAEkB,qBAAuBhB,IAAOiB,GAAhC,KAWAnB,EAAEoB,UAAYlB,IAAOiB,GAArB,KAUAnB,EAAEqB,OAASnB,IAAOoB,GAAlB,KAMAtB,EAAEuB,SAAWrB,IAAOoB,GAApB,KAOAtB,EAAEwB,aAAetB,IAAOC,IAAxB,IAOYG,YAAS,YAIrBN,EAAEyB,cAAgBvB,IAAOC,IAAzB,KAOAH,EAAE0B,QAAUxB,IAAOyB,EAAnB,IAGUrB,YAAS,UAEnBN,EAAE4B,UAAY1B,IAAOyB,EAArB,IAEUrB,YAAS,aAUnBN,EAAE6B,WAAa3B,IAAOC,IAAtB,KAaAH,EAAE8B,eAAiB5B,IAAOC,IAA1B,IASsBG,YAAS,SAM/BN,EAAE+B,MAAQ7B,IAAOC,IAAjB,KAMAH,EAAEgC,QAAU9B,IAAOC,IAAnB,KAIAH,EAAEiC,MAAQ/B,IAAOC,IAAjB,KAGA,IAgJI+B,EA9FF,SAASX,EAAT,GAA4B,IAARY,EAAO,EAAPA,KAClB,OACE,kBAACnC,EAAEuB,SAAH,KACE,kBAACvB,EAAEwB,aAAH,KACE,kBAACxB,EAAE0B,QAAH,eAAeS,EAAKC,MACpB,kBAACpC,EAAE4B,UAAH,KAAcO,EAAKE,MAAMC,aAE3B,kBAACtC,EAAEyB,cAAH,KACE,8BAAOU,EAAKI,SAQtB,SAASV,EAAT,GAA8F,EAAxEW,MAAwE,EAAjEC,IAAkE,IAA7DC,EAA4D,EAA5DA,MAAcC,GAA8C,EAArDC,MAAqD,EAA9CD,UAAUJ,EAAoC,EAApCA,MAAOM,EAA6B,EAA7BA,SAAUC,EAAmB,EAAnBA,KAAMC,EAAa,EAAbA,UAK3EC,EAvEiB,SAACC,GACtB,IAAID,EAAc,CAAC,KAAM,MAyBzB,OAvBAC,EAAUC,SAAQ,SAAAT,GAChB,IAAIU,EAAUC,EAAOC,SAASC,cAAhB,gBAAuCb,IACrD,GAAGU,GAAWA,EAAQI,SAAS,GAAG,CAChC,IACIC,EADSL,EAAQI,SAAS,GACZE,wBACdC,EAAY,CAAEC,EAAGH,EAAKI,KAAMC,EAAGL,EAAKM,KACpCC,EAAa,CAAEJ,EAAGH,EAAKQ,MAAOH,EAAGL,EAAKS,QACtCjB,EAAY,IAGXU,EAAUC,EAAIX,EAAY,GAAGW,IAAGX,EAAY,GAAGW,EAAID,EAAUC,GAC7DD,EAAUG,EAAIb,EAAY,GAAGa,IAAGb,EAAY,GAAGa,EAAIH,EAAUG,IAHhEb,EAAY,GAAKU,EAKfV,EAAY,IAGXe,EAAWJ,EAAIX,EAAY,GAAGW,IAAGX,EAAY,GAAGW,EAAII,EAAWJ,GAC/DI,EAAWF,EAAIb,EAAY,GAAGa,IAAGb,EAAY,GAAGa,EAAIE,EAAWF,IAHlEb,EAAY,GAAKe,MAShBf,EA6CWkB,CAAevB,GAC7BwB,EAAS,GAab,OAZGnB,GAAeA,EAAY,KAC5BmB,EAAS,CAKPP,KAAMZ,EAAY,GAAGW,EACrBG,IAAKd,EAAY,GAAGa,IAMtB,kBAAC7D,EAAE6B,WAAH,CACEuC,MAAQD,EACRE,UAAYtB,EAAY,UAAY,UAIpC,kBAAC/C,EAAEgC,QAAH,KACGc,EAAKwB,OAAS,EACb,kBAACtE,EAAEoB,UAAH,KACG0B,EAAKyB,KAAI,SAACC,EAAGC,GAAJ,OAAU,kBAAClD,EAAD,CAAUmD,IAAKD,EAAGtC,KAAMqC,QAG9C,kBAACxE,EAAEoB,UAAH,KACE,kBAACpB,EAAEqB,OAAH,KAAU,8BAAO,uBAIvB,kBAACrB,EAAEiC,MAAH,KACE,8BAAOS,GACP,2CACA,kBAAC1C,EAAEa,cAAH,KAAkBgC,GAElB,8BAAO,MACP,8BAAON,IAET,kBAACvC,EAAE8B,eAAH,OAmGS6C,IAhEf,WAAyB,IAAD,EACoBC,qBAAWC,KAA7CC,EADc,EACdA,OAAQC,EADM,EACNA,KAAMC,EADA,EACAA,gBADA,EAEcC,oBAAS,GAFvB,mBAEdlC,EAFc,KAEHmC,EAFG,KAIhBC,EAAiBC,mBAAQ,kBAC7BC,IAAWC,mBAAmBR,EAAQC,KACtC,CAAED,EAAQC,IAGNQ,EAAQH,mBAAQ,kBACpBD,EAAeK,MAAK,SAAAD,GAAK,OAAIA,EAAM9C,MAAQuC,OAC3C,CAAEG,EAAgBH,IAKpB,SAASS,EAAaC,GAMjBxD,IACDyD,OAAOC,aAAa1D,GACpBA,EAAQ,MANVA,EAAQyD,OAAOE,WAAWH,EAAU,GA2BtC,OAjBAI,qBAAU,WACLP,EACEP,IAAoBO,EAAM9C,IAC3ByC,GAAa,GAETnC,GACF0C,GAAa,WACXP,GAAa,MAKnBA,GAAa,KAGjB,CAAEK,EAAOxC,EAAWiC,EAAiBE,IAGnC,kBAAClF,EAAEC,UAAH,CAAa8F,GAAG,wBACbR,GACC,kBAAC1D,EAAD,CACEkB,UAAWA,EACXH,MAAO2C,EAAMS,YACbrD,SAAU4C,EAAM5C,SAChBF,IAAK8C,EAAM9C,IACXD,MAAQyD,IAAYC,cAAcX,EAAM9C,KACxCC,MAAO6C,EAAM7C,MACbH,MAAOgD,EAAMhD,MACbM,SAAU0C,EAAM1C,SAChBC,KAAMyC,EAAMzC,W,yKClcf,IAyDMxC,EAAW,SAAC6F,GACvB,OAAOC,EAAMC,MAAMF,IAGRG,EAAY,SAACC,GACxB,OAAOH,EAAMI,OAAOD,IA6BhBE,EAEW,QAFXA,EAGU,QAHVA,EAII,QAJJA,EAKK,SAWLL,GAPQ,eAAD,OARE,QAQF,KACG,eAAD,OAAiBK,EAAjB,KACA,eAAD,OAAiBA,EAAjB,KACL,eAAD,OAAiBA,EAAjB,KACE,eAAD,OAAiBA,EAAjB,KAGK,CACZJ,MAAM,CACJK,MAAO,UACPC,KAAM,UACNC,WAAY,UACZC,MAAO,UACPC,KAAM,UACNC,MAAO,UACPC,OAAQ,UACRC,OAAQ,UACRC,OAAQ,UACRC,KAAM,UACNC,QAAS,UACTC,UAAW,UACXC,UAAW,UACXC,SAAU,WAEZf,OAAO,CACLgB,GAAI,+CACJC,GAAI,+CACJC,GAAI,2CAENrF,MAAM,CACJsF,aAAc,SACdC,UAAW,SAEbC,OAAO,GACPpB,YAAY,CACVqB,YAAa,QACbC,cAAe,QACfC,aAAc,QACdC,OAAQ,QACRC,QAAS,a,+4DCvIb,IAAMlI,EAAI,GAEVA,EAAEmI,KAAOjI,IAAOC,IAAhB,KACsB,SAAAwB,GAAC,OAAIA,EAAEyG,OAAS,WAIzB,SAAAzG,GAAC,OAAIA,EAAE0G,SAChB,SAAA1G,GAAC,OAAIA,EAAE2G,YAAcC,YAAhB,QAIL,SAAA5G,GAAC,OAAIA,EAAE6G,OAASD,YAAX,KAMLA,YANK,QAWTvI,EAAEyI,UAAYvI,IAAOC,IAArB,KAKI,SAAAwB,GAAC,OAAIA,EAAE6G,OAASD,YAAX,KAGLA,YAHK,OAWOjC,YAAU,OACtB,SAAA3E,GAAC,MAAqB,YAAjBA,EAAE+G,YAA4BH,YAA9B,IACyBjI,YAAS,eAEvC,SAAAqB,GAAC,MAAqB,YAAjBA,EAAE+G,YAA4BH,YAA9B,IACyBjI,YAAS,gBAGvC,SAAAqB,GAAC,OAAIA,EAAE2G,YAAcC,YAAhB,QAOTvI,EAAE2I,WAAazI,IAAOM,IAAtB,KAOAR,EAAE4I,YAAc1I,IAAOyB,EAAvB,KAkCekH,MA5Bf,YAA+H,IAAvGC,EAAsG,EAAtGA,YAAaC,EAAyF,EAAzFA,YAAaC,EAA4E,EAA5EA,SAAUC,EAAkE,EAAlEA,QAASP,EAAyD,EAAzDA,WAAYQ,EAA6C,EAA7CA,aAAcV,EAA+B,EAA/BA,OAAQrG,EAAuB,EAAvBA,KAAuB,IAAjBiG,aAAiB,MAAX,QAAW,EAC5H,OACE,kBAACpI,EAAEmI,KAAH,CACEpC,GAAE,eAAU5D,EAAKgH,SACjBf,MAAOA,EACPE,aAAcY,EACdJ,YAAa,SAAAM,GAAC,OAAIN,EAAYM,EAAGjH,EAAKgH,UACtCJ,YAAa,SAAAK,GAAC,OAAIL,EAAYK,EAAGjH,EAAKgH,QAAShH,EAAKkH,WACpDhB,MAAOlG,EAAKmH,MACZC,IAAKN,EACLT,OAAQA,EACRpE,MAAOoE,EAAS,KAAO,CACrB5E,KAAK,GAAD,OAAKoF,EAASrF,EAAd,MACJG,IAAI,GAAD,OAAKkF,EAASnF,EAAd,QAGL,kBAAC7D,EAAEyI,UAAH,CACEH,aAAcY,EACdV,OAAQA,EACRE,WAAYA,GAEZ,kBAAC1I,EAAE4I,YAAH,KAAgBY,YAAmBrH,EAAKsH,SACxC,kBAACzJ,EAAE2I,WAAH,CAAce,IAAKvH,EAAKwH,KAAKC,SAAUC,WAAW,OC8C3CC,MAjHf,YAA8C,IAAxB3H,EAAuB,EAAvBA,KAAuB,IAAjBiG,aAAiB,MAAX,QAAW,IACNxD,qBAAWC,KAAxCkF,EADmC,EACnCA,QAAS/E,EAD0B,EAC1BA,gBAD0B,EAGfC,mBAAS,CACnCiE,aAAc,KACdc,gBAAgB,IALyB,mBAGnCC,EAHmC,KAG5BC,EAH4B,KAQrCjB,EAAUkB,iBAAO,MAEjBpB,EAAcqB,uBAAY,SAAChB,EAAGD,EAASE,GAC3CU,EAAQM,kBAAkBlB,GAC1BY,EAAQO,mBAAmBjB,KAC1B,CAAEU,EAAQO,mBAAoBP,EAAQM,oBAEnCvB,EAAcsB,uBAAY,WAAuBjB,GAAa,IAAjCoB,EAAgC,EAAhCA,QAASC,EAAuB,EAAvBA,QAC1CT,EAAQU,SAAStB,GAEjBe,GAAS,SAAAD,GAAK,kCACTA,GADS,IAEZD,gBAAgB,EAChBd,aAAc,CACZvF,EAAG4G,EACH1G,EAAG2G,UAGN,CAAET,EAAQU,WAEPC,EAAsBN,uBAAY,YAA2B,IAAxBG,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,QAElDN,GAAS,SAAAD,GAAK,kCACTA,GADS,IAEZf,aAAc,CACZvF,EAAG4G,EACH1G,EAAG2G,UAIN,IAEGG,EAAqBP,uBAAY,YAA2B,IAAxBG,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,QACjDN,GAAS,SAAAD,GAAK,kCACTA,GADS,IAEZD,gBAAgB,EAChBd,aAAa,UAIfa,EAAQa,SAASzI,EAAKgH,QAAS,QAAS,CACtCxF,EAAG4G,EACH1G,EAAG2G,MAGJ,CAAErI,EAAKgH,QAASY,EAAQa,WAE3B9E,qBAAU,WACLmE,EAAMD,gBACPf,EAAQ4B,QAAQC,iBAAiB,aAAcH,GAC/C1B,EAAQ4B,QAAQC,iBAAiB,YAAaJ,GAC9CzB,EAAQ4B,QAAQC,iBAAiB,UAAWH,KAE5C1B,EAAQ4B,QAAQE,oBAAoB,aAAcJ,GAClD1B,EAAQ4B,QAAQE,oBAAoB,YAAaL,GACjDzB,EAAQ4B,QAAQE,oBAAoB,UAAWJ,MAEhD,CAAEV,EAAMD,iBAGXlE,qBAAU,WACJmE,EAAMe,aACRd,GAAS,SAAAD,GAAK,kCACTA,GADS,IAEZD,gBAAe,EACfd,aAAc,CACZvF,EAAGxB,EAAK6G,SAASrF,EACjBE,EAAG1B,EAAK6G,SAASnF,UAItB,CAAEoG,EAAMe,cAEX,IAtGmBC,EAAiB/B,EAsGhCF,GAtGeiC,EAsGQ9I,EAAK6G,SAtGIE,EAsGMe,EAAMf,aAAc/G,EAAKsH,SArGrDyB,IAAWC,KAChB,CACLxH,EAAG,EACHE,EAAG,GAIFqF,EACI,CACLvF,EAAGuF,EAAavF,EAChBE,EAAGqF,EAAarF,GAGX,CACLF,EAAGsH,EAAgBtH,EACnBE,EAAGoH,EAAgBpH,IAwFjB6E,EAAatD,mBAAQ,WAEvB,OAAsB,IAAnBjD,EAAKkH,SACC,KAEJrE,IAAoB7C,EAAKkH,SACnB,UAEA,YAIb,CAAElH,EAAKkH,SAAUrE,IAGnB,OACE,kBAAC,EAAD,CACE7C,KAAMA,EACNiG,MAAOA,EACPU,YAAaA,EACbC,YAAaA,EACbE,QAASA,EACTT,QAAQ,EACRQ,SAAUA,EACVE,aAAce,EAAMf,aACpBR,WAAYA,K,+8BCjIlB,IAAM1I,EAAI,GAEVA,EAAEC,UAAYC,IAAOC,IAArB,KAMAH,EAAEoL,YAAclL,IAAOC,IAAvB,IAGsBG,YAAS,UAMPA,YAAS,SACvBA,YAAS,SAOKA,YAAS,SAClBA,YAAS,SAKxBN,EAAEI,GAAKF,IAAOC,IAAd,KAWAH,EAAEqL,SAAWnL,IAAOyB,EAApB,IAOUrB,YAAS,UA8BJgL,MA3Bf,WAAqB,IACXvB,EAAYnF,qBAAWC,KAAvBkF,QAER,OACE,kBAAC,EAAE9J,UAAH,KACE,kBAAC,EAAEmL,YAAH,CAAeG,QAAS,kBAAMxB,EAAQyB,YAAYC,KAAK,UACpD,QAEH,kBAAC,EAAEL,YAAH,CAAeG,QAAS,kBAAMxB,EAAQ2B,SAAS,IAAID,KAAK,UACrD,eAEH,kBAAC,EAAEL,YAAH,CAAeG,QAAS,kBAAMxB,EAAQ4B,eAAeF,KAAK,UACvD,eAEH,6BACA,kBAAC,EAAEL,YAAH,CAAeG,QAAS,kBAAMxB,EAAQ2B,SAAS,KAAKD,KAAK,UACtD,UAEH,kBAAC,EAAEL,YAAH,CAAeG,QAAS,kBAAMxB,EAAQ6B,qBAAqBH,KAAK,UAC7D,kBAEH,kBAAC,EAAEJ,SAAH,KAAa,QACb,kBAAC,EAAEjL,GAAH,Q,2dC7EN,IAAMJ,EAAI,GAEVA,EAAEC,UAAYC,IAAOC,IAArB,K,IA0BM0L,E,kDAGJ,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IACDC,QAAUC,IAAMC,YACrB,EAAKC,eAAiB,EAAKA,eAAeC,KAApB,gBAHL,E,gEAMC,IAAD,IACjBxG,OAAOmF,iBAAiB,SAAUsB,KAAKF,gBACvCE,KAAKC,QAAQtC,QAAQuC,QAAQ,OAA7B,UAAqCF,KAAKL,eAA1C,iBAAqC,EAAclB,eAAnD,aAAqC,EAAuBpH,2B,6CAI5DkC,OAAOoF,oBAAoB,SAAUqB,KAAKF,kB,uCAG3B,IAAD,IACdE,KAAKC,QAAQtC,QAAQuC,QAAQ,OAA7B,UAAqCF,KAAKL,eAA1C,iBAAqC,EAAclB,eAAnD,aAAqC,EAAuBpH,2B,+BAI5D,OACE,kBAAC,EAAExD,UAAH,CACEsJ,IAAK6C,KAAKL,SACV,2BAAI,4B,GA1BWC,IAAMO,WAAvBV,EACGW,YAAc3H,IA+BRgH,Q,q6GCvDf,IAAM7L,GAAI,GAEVA,GAAEC,UAAYC,IAAOC,IAArB,MAIAH,GAAEI,GAAKF,IAAOC,IAAd,MASAH,GAAEK,QAAUH,IAAOC,IAAnB,KAMuBG,YAAS,SACXA,YAAS,QAIGA,YAAS,UAI1CN,GAAEO,OAASL,IAAOM,IAAlB,MAYAR,GAAE6B,WAAa3B,IAAOC,IAAtB,MASAH,GAAEyM,eAAiBvM,IAAOC,IAA1B,MAKAH,GAAES,kBAAoBP,IAAOQ,GAA7B,KACkBJ,YAAS,UAM3BN,GAAEW,iBAAmBT,IAAOC,IAA5B,MAYAH,GAAEY,SAAWV,IAAOC,IAApB,MAKAH,GAAEa,cAAgBX,IAAOY,KAAzB,KAEWR,YAAS,YAGpBN,GAAEe,mBAAqBb,IAAOC,IAA9B,KAGaG,YAAS,YAGPA,YAAS,UAKxBN,GAAEgB,WAAad,IAAOC,IAAtB,KASeG,YAAS,SAKTA,YAAS,aACSA,YAAS,UAK1CN,GAAEiB,aAAef,IAAOC,IAAxB,MASAH,GAAEkB,qBAAuBhB,IAAOiB,GAAhC,KAWAnB,GAAEoB,UAAYlB,IAAOiB,GAArB,KAUAnB,GAAEqB,OAASnB,IAAOoB,GAAlB,KAMAtB,GAAEuB,SAAWrB,IAAOoB,GAApB,KAOAtB,GAAEwB,aAAetB,IAAOC,IAAxB,IAOYG,YAAS,YAIrBN,GAAEyB,cAAgBvB,IAAOC,IAAzB,KAMAH,GAAE0B,QAAUxB,IAAOyB,EAAnB,IAGUrB,YAAS,UAEnBN,GAAE4B,UAAY1B,IAAOyB,EAArB,IAEUrB,YAAS,aCrJJoM,OArCf,YAA4C,IAAxBvK,EAAuB,EAAvBA,KAAuB,IAAjBiG,aAAiB,MAAX,QAAW,EACjC2B,EAAYnF,qBAAWC,KAAvBkF,QADiC,EAGb9E,mBAAS,CACnCiE,aAAc,OAJyB,mBAGjCe,EAHiC,KAOnChB,GAPmC,KAOzBkB,iBAAO,OAEjBpB,EAAcqB,uBAAY,SAAChB,EAAGD,EAASE,GAC3CU,EAAQM,kBAAkBlB,GAC1BY,EAAQO,mBAAmBjB,KAC1B,CAAEU,EAAQO,mBAAoBP,EAAQM,oBAGnCvB,EAAcsB,uBAAY,WAAuBjB,GAAa,IAAjCoB,EAAgC,EAAhCA,QAASC,EAAuB,EAAvBA,QAC1CT,EAAQU,SAAStB,EAAS,CACxBxF,EAAG4G,EACH1G,EAAG2G,MAEJ,CAAET,EAAQU,SAAUV,EAAQa,WAE/B,OACE,kBAAC,EAAD,CACEzI,KAAMA,EACNiG,MAAOA,EACPU,YAAaA,EACbC,YAAaA,EACbE,QAASA,EACTT,QAAQ,EACRQ,SAAU,CAACrF,EAAE,EAAEE,EAAE,GACjBqF,aAAce,EAAMf,aACpBR,WAAY,U,2MChClB,IAAM1I,GAAI,GAEVA,GAAE2M,KAAOzM,IAAOC,IAAhB,MAiCewM,OAvBf,WAAiB,IACP5H,EAASH,qBAAWC,KAApBE,KAEF6H,EAAcxH,mBAAQ,WAKxB,OAJmBL,EAAK8H,QAAO,SAAAC,GAAC,OAAIA,EAAErD,SAAWyB,IAAWC,QAAM5G,KAAI,SAACwI,EAAGtK,GAAJ,mBAAC,eAClEsK,GADiE,IAEpEC,aAAcvK,SAIlB,CAAEsC,IAIJ,OACE,kBAAC,GAAE4H,KAAH,CAAQ5G,GAAG,QACR6G,EAAYrI,KAAI,SAAAwI,GAAC,OAChB,kBAAC,GAAD,CAAU5K,KAAM4K,EAAGrI,IAAKqI,EAAE5D,e,SCA9B8D,GAAU,EA+BRC,GAAqB,SAAAnI,GACzB,IACE,OAAIA,GAAwB,IAAhBA,EAAKT,OACVS,EAAKA,EAAKT,OAAS,GAAG6E,QAAU,EADD,EAEvC,MAAMC,GAEL,OADA+D,QAAQC,MAAM,oCAAqCrI,GAC5C,IAsFI,IACbsI,mBAvIyB,SAACC,EAAUC,EAAUC,GAC9C,IAAIC,EAAU,EACd,OAAOF,EAAShJ,KAAI,SAAAwI,GAAC,MAAK,CACxBW,MAAOX,EAAEW,OAAS,WAClB9D,SAAU+D,GAAWC,mBAAmBb,EAA9B,kBAA4CO,IACtDxK,KAAM6K,GAAWE,UAAUd,EAAEjK,KAAM0K,GACnCC,QAASA,QACPK,QAiIJD,UA7JgB,SAACE,EAAWP,GAC5B,OAAIO,EAEGA,EAAUxJ,KAAI,SAAAC,GAAC,MAAK,CACzBpC,IAAKoC,EAAE,GACPnC,MAAOmC,EAAE,GACTwJ,YAAaxJ,EAAE,GACfjC,MAAOiL,EAAShJ,EAAE,KAAO,MANL,IA6JtByJ,YA/BkB,SAAC9E,EAAS+E,EAAMnJ,EAAMoJ,EAAWC,GACnD,IAAIC,EAAeV,GAAWW,sBAAsBvJ,EAAMmJ,EAAMC,GAChE,IAAIE,GAAwC,IAAxBA,EAAa/J,OAE/B,OADA6I,QAAQoB,KAAK,sBACN,KAGT,IACIC,EAAWH,EADDI,KAAKC,MAAMD,KAAKE,SAAWN,EAAa/J,SAElDsK,EArGG,CACLjL,EAAG,KAFLsJ,IAAW,GAGTpJ,EAAG,IAAMoJ,IAqGX,MAAO,CACL9D,QAASA,EACTsE,QAASe,EAASf,QAClB9D,KAAM6E,EACN/E,OAAQyB,IAAWC,KACnB7B,MAAO8E,EACPpF,SAAU4F,IAeZC,aAXmB,SAACC,EAAU3F,GAC9B,IAAM4F,EAAOD,EAAS3F,GACtB,OAAI4F,GAAa,MAUjBT,sBA1G4B,SAACU,EAAad,EAAMC,GAGhD,OAFIA,IAAWA,EAAY,IAEpBD,EAAKrB,QAAO,SAACoC,EAAGxM,GAErB,QADeuM,EAAYxJ,MAAK,SAAA0J,GAAE,OAAIA,EAAGzB,UAAYwB,EAAGxB,YAAYU,EAAUgB,QAAQF,EAAGxB,UAAY,OAuGvG2B,YA9DkB,SAACC,EAAWnB,EAAMnJ,EAAMuK,GAC1C,IAAMC,EAAU,GACVpB,EAAY,GACdqB,EAAW,OACEC,IAAdH,IACDA,EAAY,GAIXvK,EACDyK,EAAWtC,GAAmBnI,GAE9BA,EAAO,GAGT,IAAI,IAAIN,EAAI,EAAGA,EAAI4K,EAAW5K,IAAI,CAChC,IAAIiL,EAAU/B,GAAWM,YAAaxJ,EAAI+K,EAAWtB,EAAMnJ,EAAMoJ,EAAWmB,KACzEI,GACDvB,EAAUwB,KAAKD,EAAQjC,SAEzBiC,GAAWH,EAAQI,KAAKD,GAG1B,OAAOH,GAwCPK,gBAzFsB,SAAC1B,EAAMnJ,EAAMuK,GACnC,IAAMC,EAAU,GACVpB,EAAY,GACdqB,EAAW,OACEC,IAAdH,IACDA,EAAY,GAIXvK,EACDyK,EAAWtC,GAAmBnI,GAE9BA,EAAO,GAGT,IAAI,IAAIN,EAAI,EAAGA,EAAIyJ,EAAK5J,OAAQG,IAAI,CAClC,IAAIiL,EAAU/B,GAAWM,YAAaxJ,EAAI+K,EAAWtB,EAAMnJ,EAAMoJ,EAAWmB,KACzEI,GACDvB,EAAUwB,KAAKD,EAAQjC,SAEzBiC,GAAWH,EAAQI,KAAKD,GAG1B,OAAOH,GAmEP3B,mBAxJyB,SAACb,EAAG8C,GAC7B,OAAG9C,EAAE+C,UACG,GAAN,OAAUD,EAAV,mBAA6B9C,EAAE+C,WACxB/C,EAAEnD,SACFmD,EAAEnD,SAEF,8BCjBLxD,GAAQ,CACZ,OAAU,GACV,SAAY,GACZ,SAAY,GACZ,KAAQ,MAwFK,IACb2J,aAtFmB,SAACC,EAAWC,GAC/B7J,GAAM8J,OAASF,GAsFfG,gBAnFsB,SAACC,EAAc5C,EAAU6C,GAC/CjK,GAAMoH,SAAWA,EACjBpH,GAAMkK,KAAOD,EAEb,IAAI5C,EAAU,EACdrH,GAAMmK,SAAWH,EAAa7L,KAAI,SAAAwI,GAAC,MAAK,CACtChH,GAAIgH,EAAEhH,GACN2H,MAAOX,EAAEW,OAAS,WAClB9D,SAAU4G,GAAU5C,mBAAmBb,EAA7B,kBAA2CsD,IACrDvN,KAAM0N,GAAU3C,UAAUd,EAAEjK,KAAM0K,GAClCC,QAASA,QACPK,QAyEJ2C,oBAvD0B,SAACC,EAAQC,GACnC,IAAMC,EAAUF,EAASC,EACzB,OAAGC,EAAU,GACXzD,QAAQ0D,IAAI,sBACJ,GAGPzK,GAAM8J,OAAO5L,OAASsM,EAChBA,GAEPzD,QAAQ0D,IAAI,oBACJ,IA6CVC,SAtEe,SAACb,GAChB,IAEE,OAAO7J,GAAM8J,OAAOD,GACrB,MAAM7G,GACL+D,QAAQC,MAAM,sCAkEhB2D,aAvBmB,SAACd,GAEpB,GADA9C,QAAQ0D,IAAI,gBACTG,MAAMf,GAEP,OADA9C,QAAQC,MAAM,sCAAuC6C,GAC9C,GAGT,GADWtC,GAAWmD,SAASb,GACzB/B,KAAK,CACT,IAAI+C,EAAetD,GAAWmD,SAASb,GAAU/B,KACjD,OAAOP,GAAWuD,cAAcrE,QAAO,SAAAE,GAAC,OAAIkE,EAAa9B,QAAQpC,EAAEhH,KAAO,KAG1E,OAAO4H,GAAWuD,eAYpBC,aA3CmB,SAAClB,GACpB9C,QAAQ0D,IAAI,eAAgBZ,EAAU7J,GAAM8J,QAC5C,IACE,MAAO,CACLzN,IAAKwN,EACLmB,YAAahL,GAAM8J,OAAOD,GAAUmB,YACpC1D,MAAOtH,GAAM8J,OAAOD,GAAUvC,OAEjC,MAAMtE,GACL,MAAO,CACL3G,KAAM,EACN2O,YAAa,OAiCjBC,SATe,kBAAMjL,IAUrB8K,YA9BkB,WAClB,OAAO9K,GAAMmK,UA8Bbe,aAjEmB,WACnB,OAAOlL,GAAM8J,OAAO5L,S,gpCClCtB,IAAMtE,GAAI,GA4DV,SAASuR,GAAT,GAAsD,IAA/BtB,EAA8B,EAA9BA,SAAU1E,EAAoB,EAApBA,QAASiG,EAAW,EAAXA,SACxC,OACE,kBAAC,GAAEpG,YAAH,CAAeoG,SAAUA,EAAUjG,QAAS,kBAAMA,EAAQ0E,IAAWxE,KAAK,UAA1E,UACMwE,EAAW,IA7DrBjQ,GAAEC,UAAYC,IAAOC,IAArB,MAIAH,GAAEI,GAAKF,IAAOC,IAAd,MASAH,GAAEyR,SAAWvR,IAAOC,IAApB,KAOUG,YAAS,UAInBN,GAAEqL,SAAWnL,IAAOyB,EAApB,MAGA3B,GAAE0R,UAAYxR,IAAOyB,EAArB,MAIA3B,GAAEoL,YAAclL,IAAOC,IAAvB,KAKsBG,YAAS,UAKPA,YAAS,SACvBA,YAAS,SAMKA,YAAS,SAClBA,YAAS,SAIpB,SAAAqB,GAAC,OAAIA,EAAE6P,UAAYjJ,YAAd,KACejI,YAAS,YAqDlBqR,OAzCf,WAAsB,IAAD,EACwB/M,qBAAWC,KAA9CmL,EADW,EACXA,UAAW9B,EADA,EACAA,KAAMnJ,EADN,EACMA,KAAMgF,EADZ,EACYA,QAiBzB6H,EAAqBxM,mBAAQ,kBACjC8I,EAAK5J,OAASS,EAAKT,SACnB,CAAE4J,EAAK5J,OAAQS,EAAKT,SAGtB,OACE,kBAAC,GAAErE,UAAH,KACE,kBAAC,GAAEmL,YAAH,CAAeG,QAAS,kBAAMxB,EAAQ8H,aAAapG,KAAK,UACrD,KAvBc,SAAC/I,GAEpB,IADA,IAAIoP,EAAU,GADgB,WAEtBrN,GACNqN,EAAQnC,KACN,kBAAC4B,GAAD,CACE7M,IAAKD,EACLwL,SAAUxL,EACV+M,SAAUxB,EAAUvN,MAAQgC,EAC5B8G,QAAS,kBAAMxB,EAAQgI,SAAStN,QAN9BA,EAAI,EAAGA,EAAI/B,EAAO+B,IAAK,EAAvBA,GAUR,OAAOqN,EAaHE,CAAaC,GAAWX,gBAC1B,kBAAC,GAAElG,YAAH,CAAeG,QAAS,kBAAMxB,EAAQmI,aAAazG,KAAK,UACrD,KAEH,kBAAC,GAAEgG,SAAH,KACE,kBAAC,GAAEpG,SAAH,sBAAuB2E,EAAUvN,IAAM,EAAvC,cAA8CuN,EAAUtC,MAAxD,MACA,kBAAC,GAAEgE,UAAH,eAAiBE,EAAjB,iBAEF,kBAAC,GAAExR,GAAH,Q,o0CCxGN,IAAMJ,GAAI,GAEVA,GAAEC,UAAYC,IAAOC,IAArB,MAOAH,GAAEI,GAAKF,IAAOC,IAAd,KAMuBG,YAAS,SACXA,YAAS,QAKGA,YAAS,UAK1CN,GAAEmS,WAAajS,IAAOC,IAAtB,MAIAH,GAAEgB,WAAad,IAAOC,IAAtB,KAIcG,YAAS,SAQTA,YAAS,YAKvBN,GAAEoS,YAAclS,IAAOC,IAAvB,KAIcG,YAAS,SAOTA,YAAS,cAKvBN,GAAEY,SAAWV,IAAOC,IAApB,KAScG,YAAS,SAuCR+R,OAlCf,WAAqB,IAAD,EACkBzN,qBAAWC,KAAvCC,EADU,EACVA,OAAQC,EADE,EACFA,KAAMiL,EADJ,EACIA,UAChB7K,EAAiBC,mBAAQ,kBAC7BC,IAAWC,mBAAmBR,EAAQC,KACtC,CAAED,EAAQC,IAGNuN,EAAalN,mBAAQ,kBACzBC,IAAWkN,eAAepN,KAC1B,CAAEA,IAQJ,OALiBC,mBAAQ,kBACvBC,IAAWmN,aAAaF,EAAYvN,EAAKT,UACzC,CAAEgO,EAAYvN,EAAKT,SAInB,kBAAC,GAAErE,UAAH,KACE,kBAAC,GAAEkS,WAAH,KACE,kBAAC,GAAEnR,WAAH,KACE,2BAAI,SACJ,2BAAIsR,IAEN,kBAAC,GAAEF,YAAH,KACE,2BAAI,UACJ,2BAAIpC,EAAUoB,eAGlB,kBAAC,GAAEhR,GAAH,Q,moDClGN,IAAMJ,GAAI,GAGVA,GAAEyS,MAAQvS,IAAOC,IAAjB,MAUAH,GAAE0S,SAAWxS,IAAOC,IAApB,MAOAH,GAAEsL,SAAWpL,IAAOC,IAApB,MAOAH,GAAE2R,UAAYzR,IAAOC,IAArB,MAQAH,GAAEqS,SAAWnS,IAAOC,IAApB,MAUAH,GAAE2S,cAAgBzS,IAAOC,IAAzB,MASAH,GAAE4S,YAAc1S,IAAOC,IAAvB,MAQAH,GAAEI,GAAKF,IAAOC,IAAd,KAIsBG,YAAS,UAO/BN,GAAE6S,QAAU3S,IAAOM,IAAnB,MAMAR,GAAE8S,cAAgB5S,IAAOC,IAAzB,MAIAH,GAAE+S,kBAAoB7S,IAAOC,IAA7B,MA4EesS,OAtEf,WAAkB,IAAD,EACwB7N,qBAAWC,KAA1CkF,EADO,EACPA,QAAShF,EADF,EACEA,KAAMiO,EADR,EACQA,WAGjBC,EAAgB7I,uBAAY,WAChCL,EAAQO,oBAAoB,GAC5BP,EAAQM,mBAAmB,KAC1B,CAAEN,EAAQO,mBAAoBP,EAAQM,oBAEzCvE,qBAAU,WACR,IACMoN,EADY,IAAIC,gBAAgBxN,OAAOyN,SAASC,QAC5BC,IAAI,QAC3BJ,EACDnJ,EAAQwJ,SAASL,GAEjBnJ,EAAQwJ,aAET,CAAExJ,EAAQwJ,WAEb,IAAMC,EAAepO,mBAAQ,kBAC3BL,EAAK8H,QAAO,SAAAC,GAAC,OAAIA,EAAErD,OAASyB,IAAWC,MAAQ2B,EAAErD,OAASyB,IAAWuI,eACrE,CAAE1O,IAGJ,OAAIiO,EAKF,kBAAC,GAAEP,MAAH,KACE,kBAAC,GAAD,MACA,kBAAC,GAAEnH,SAAH,KACE,kBAAC,EAAD,OAEF,kBAAC,GAAEqG,UAAH,KACE,kBAAC,GAAD,OAEF,kBAAC,GAAEU,SAAH,KACE,2BAAI,QACJ,kBAAC,GAAD,OAEF,kBAAC,GAAEO,YAAH,KACE,kBAAC,EAAD,CAAUc,OAAQ,aAKpB,kBAAC,KAAD,MAGA,kBAAC,GAAEZ,cAAH,CAAiB/M,GAAG,MACjByN,EAAajP,KAAI,SAACwI,EAAGtK,GAAJ,OAChB,kBAAC,EAAD,CAAYN,KAAM4K,EAAGrI,IAAKqI,EAAE5D,cAUhC,kBAAC,GAAE/I,GAAH,CAAM2I,YAAakK,GAEjB,kBAAC,GAAEJ,QAAH,CAAWnJ,IAAK,4BAvCb,4BAAK,eCtGD,GA1BE,SAACiK,EAAKjO,GACrByH,QAAQ0D,IAAR,uBAA4B8C,EAA5B,QACA,IAAIC,EAAM,IAAIC,eACdD,EAAIE,KAAK,MAAOH,GAChBC,EAAIG,KAAK,MAETH,EAAII,mBAAqB,WAGvB,IACE,GAHS,IAGLJ,EAAIK,WACN,GAHK,MAGDL,EAAInK,OAAe,CACrB0D,QAAQ0D,IAAR,uBAEA,IAAIqD,EAAWC,KAAKC,MAAMR,EAAIS,cAC9B3O,EAASwO,QAET/G,QAAQC,MAAR,kCAAyCuG,EAAzC,sCAAkFC,EAAInK,QAG3F,MAAML,GACL+D,QAAQC,MAAR,kCAAyCuG,EAAzC,oCAAgFvK,MCblFgF,GAAW,EAuUAkG,OAjUf,YAA4B,IAAZ/Q,EAAW,EAAXA,SAAW,EACa0B,oBAAU,GADvB,mBACjBsP,EADiB,KACLC,EADK,OAEuBvP,oBAAU,GAFjC,mBAEjBD,EAFiB,KAEAsF,EAFA,OAGqBrF,oBAAU,GAH/B,mBAGjBwP,EAHiB,KAGDpK,EAHC,OAIIpF,mBAAS,IAJb,mBAIjBF,EAJiB,KAIX2P,EAJW,OAKCzP,mBAAS,IALV,mBAKjBiJ,EALiB,KAKXyG,EALW,OAMG1P,mBAAS,IANZ,mBAMjB2P,EANiB,KAMVC,EANU,OAOK5P,mBAAS,IAPd,mBAOjBH,EAPiB,KAOTgQ,EAPS,OAQa7P,oBAAS,GARtB,mBAQjB+N,EARiB,KAQL+B,EARK,OASW9P,mBAAS,IATpB,mBASjB+K,EATiB,KASND,EATM,KAWnBiF,EAAmB5K,uBAAY,SAAA6K,GACnClF,EAAakC,GAAWd,aAAa8D,MACpC,CAAElF,IAECwD,EAAWnJ,uBAAY,SAAA8K,GAG3B,IAAMC,EAAO,kBAFbD,EAAWA,GAnBM,cAqBJ,cAEbE,GAAoBD,GAAS,SAAChT,GAC5B,IACEgL,QAAQ0D,IAAI,kBAAmB1O,GAC/B8P,GAAWlC,aAAa5N,EAAKkT,KAAKnF,QAClC+B,GAAW9B,gBAAgBhO,EAAKkT,KAAKzS,MAAOT,EAAKkT,KAAK7H,SAAUrL,EAAKkT,KAAK/E,MAG1E0E,EADiB,GAEjBL,EAAQ1C,GAAWlB,aAFF,IAGjBgE,GAAc,GAEhB,MAAM3L,GACJ+D,QAAQC,MAAM,2BAA4BhE,SAG7C,CAAE2L,EAAeC,IAEdM,EAAUlL,uBAAY,SAACrF,EAAMwQ,GAEjC,IAAMzQ,EAASmB,IAAYuP,WAAWzQ,GACtC+P,EAAUhQ,GAGV,IAAMyK,EAAUxK,EAAKR,KAAI,SAAAwI,GAAC,kCACrBA,GADqB,IAExB1D,SAAUvE,EAAO2Q,WAAU,SAAAC,GAAC,OAAIA,EAAEvG,QAAQpC,EAAE5D,UAAY,UAG1DuL,EAAWnF,GACRgG,GAAkB,GACnBjL,EAAmBiF,EAAQ/J,MAAK,SAAAuH,GAAC,OAAIA,EAAE5D,UAAYoM,KAAgBlM,YAEpE,CAAEqL,EAAYI,EAAWxK,IAEtBqL,EAAcvL,uBAAY,SAAAjB,GAC9BmM,EAAQvQ,EAAK8H,QAAO,SAAAC,GAAC,OAAIA,EAAE3D,UAAYA,QACtC,CAAEmM,EAASvQ,IAERyG,EAAWpB,uBAAY,SAAAwL,GAC3BxH,GAAW,EACX,IAAMmB,EAAUiB,GAAUpB,YAAYlB,EAAK5J,QAAUsR,GAAa,GAAI3D,GAAWlB,aAAaf,EAAUvN,KAAM,GAAI2L,IAElHA,IAAYmB,EAAQjL,OACpBgR,EAAQ/F,KACP,CAAE+F,EAAStF,EAAUvN,IAAKyL,IAEvBxC,EAAWtB,uBAAY,SAAAiF,GAC3B,IAAME,EAAUiB,GAAUpB,YAAYC,EAAW4C,GAAWlB,aAAaf,EAAUvN,KAAMsC,EAAMqJ,IAE/FA,IAAYmB,EAAQjL,OACpBgR,EAAQvQ,EAAK8Q,OAAOtG,MACnB,CAAE+F,EAASvQ,EAAMiL,EAAUvN,MAExBkJ,EAAcvB,uBAAY,WAC9BgE,GAAW,EACXkH,EAAQ,MACP,CAAEA,IAEC1J,EAAoBxB,uBAAY,WACpC,GAAGrF,EAAKT,OAAS,EAAE,CACjB,IAAMwR,EAAcrH,KAAKC,MAAMD,KAAKE,SAAW5J,EAAKT,QACpDqR,EAAY5Q,EAAK+Q,GAAa3M,YAE/B,CAAEwM,EAAa5Q,IAGZuH,EAAUlC,uBAAY,SAAC2L,EAAQC,GAChCpB,EAAMpP,MAAK,SAAAyQ,GAAC,OAAIA,EAAElQ,KAAOgQ,KAC1BlB,EAASD,EAAMrQ,KAAI,SAAA0R,GACjB,OAAGA,EAAElQ,KAAOgQ,EACH,2BACFE,GADL,IAEED,OAAQ,CACNlS,IAAKkS,EAAOlS,IACZF,KAAMoS,EAAOpS,KACbI,MAAOgS,EAAOhS,MACdC,OAAQ+R,EAAO/R,UAIZgS,MAIXpB,EAASD,EAAMiB,OAAO,CACpB,CACE9P,GAAGgQ,EACHC,OAAQ,CACNlS,IAAKkS,EAAOlS,IACZF,KAAMoS,EAAOpS,KACbI,MAAOgS,EAAOhS,MACdC,OAAQ+R,EAAO/R,cAKtB,CAAE2Q,EAAOC,IAWN3C,GAAY9H,uBAAY,WAC5B,IAAM8L,EAAWjE,GAAWxB,oBAAoBT,EAAUvN,IAAK,GAC5DyT,GAAY,GACbvK,IACAqJ,EAAgBkB,GAChBvB,EAAQ1C,GAAWlB,aAAamF,KAEhC/I,QAAQ0D,IAAI,+BAEb,CAAEb,EAAUvN,IAAKuS,EAAiBrJ,IAE/BkG,GAAYzH,uBAAY,WAC5B,IAAM8L,EAAWjE,GAAWxB,oBAAoBT,EAAUvN,KAAM,GAC7DyT,GAAY,GACbvK,IACAqJ,EAAgBkB,GAChBvB,EAAQ1C,GAAWlB,aAAamF,KAEhC/I,QAAQ0D,IAAI,+BAEb,CAAEb,EAAUvN,IAAKuS,EAAiBrJ,IAE/BoG,GAAW3H,uBAAY,SAAA6F,GACRgC,GAAWnB,SAASb,IAErCtE,IACAqJ,EAAgB/E,GAChB0E,EAAQ1C,GAAWlB,aAAad,KAEhC9C,QAAQ0D,IAAR,8BAAmCZ,EAAnC,kBAED,CAAE+E,EAAiBrJ,IAEhBwK,GAAiB,SAAC1M,EAAQ2J,GAC9B,OAAGlI,IAAWkI,GACLlI,IAAWkI,GAGjB3J,IAAWyB,IAAWkL,aAChBlL,IAAWC,KACX1B,IAAWyB,IAAWmL,cACtBnL,IAAWoL,MAEX7M,GAeLgB,GAAWL,uBAAY,SAACjB,EAASH,GACrCwL,EAAcrL,GAEdmM,EAAQvQ,EAAKR,KAAI,SAAAwI,GACf,GAAGA,EAAE5D,UAAYA,EACf,OAAO,2BACF4D,GADL,IAEEtD,QAlBeA,EAkBOsD,EAAEtD,OAjB3BA,IAAWyB,IAAWC,KAChBD,IAAWkL,aAEX3M,IAAWyB,IAAWoL,MACtBpL,IAAWmL,cAEX5M,GAYHT,SAAUA,GAAsB+D,EAAE/D,WAGpC,IAtBiBS,EAsBX8M,EAAgBJ,GAAepJ,EAAEtD,QACvC,OAAGsD,EAAEtD,SAAW8M,EACP,2BACFxJ,GADL,IAEEtD,OAAQ8M,IAGHxJ,QAIZ,CAAEyH,EAAezP,EAAMuQ,IAEpBkB,GAAkBpM,uBAAY,SAAAjB,GAClCmM,EAAQvQ,EAAKR,KAAI,SAAAwI,GACf,OAAGA,EAAE5D,UAAYA,EACR,2BACF4D,GADL,IAEEtD,OAAOyB,IAAWC,OAGf4B,QAER,CAAEyH,EAAezP,EAAMuQ,IA4BpB1K,GAAWR,uBAAY,SAACjB,EAASiK,EAAUqD,GAE/CjC,GAAe,GACZrL,IAAYoL,GACbC,GAAe,GAGjB,IAAMkC,EAAY3R,EAAKS,MAAK,SAAAuH,GAAC,OAAIA,EAAE5D,UAAYA,KAC/C,GAAGuN,GAA0B,UAAbtD,EAAqB,CACnC,IAAIuD,EAAc,GAKlB,GAJGD,IACDC,EA5IqB,SAAC3N,EAAU4L,GACpC,OAAOA,EAAM/H,QAAO,SAAAoJ,GAClB,OACGjN,EAASrF,EAAIsS,EAAED,OAAOpS,MAAQoF,EAASrF,EAAIsS,EAAED,OAAOhS,OACjDgF,EAASnF,EAAIoS,EAAED,OAAOlS,KAAOkF,EAASnF,EAAIoS,EAAED,OAAO/R,UAwIzC2S,CAAmBH,EAAa7B,IAG7C+B,EAAYnR,MAAK,SAAAqR,GAAE,MAAc,SAAVA,EAAG9Q,MAG3B,YAFAyQ,GAAgBrN,GAMpBmM,EAAQvQ,EAAKR,KAAI,SAAAwI,GACf,OAAGA,EAAE5D,UAAYA,EACR,2BACF4D,GADL,IAEEtD,OAAO0M,GAAepJ,EAAEtD,OAAQ2J,GAChC9J,MAAO8E,KACPpF,SAAUyN,EAAc,CACtB9S,EAAG8S,EAAY9S,EACfE,EAAG4S,EAAY5S,GACbkJ,EAAE/D,WAIH+D,QAER,CAAEyH,EAAezP,EAAMuQ,EAASf,EAAYK,EAAO4B,KAEtD,OACE,kBAAC,IAAaM,SAAd,CACEzU,MAAO,CACL2Q,WAAYA,EACZ9E,KAAMA,EACNnJ,KAAMA,EACND,OAAQA,EACR8P,MAAOA,EACP5E,UAAWA,EACXuE,WAAYA,EACZvP,gBAAiBA,EACjByP,eAAgBA,EAChB1K,QAAQ,CACNmI,UAAWA,GACXL,UAAWA,GACXE,SAAUA,GACVvG,SAAUA,EACVE,SAAUA,EACViK,YAAaA,EACb/J,kBAAmBA,EACnBD,YAAaA,EACb4H,SAAUA,EACVjH,QAASA,EACTkI,cAAeA,EACflK,mBAAoBA,EACpBD,kBAAmBA,EACnBI,SAAUA,GACVG,SAAUA,GACV4L,gBAAiBA,MAGlBjT,I,kJCnUT,IAAMvD,GAAI,GACVA,GAAEC,UAAYC,IAAOC,IAArB,MAOAwF,OAAOoR,GAAK9E,GACZtM,OAAOqR,GAAKxG,GAYGyG,OAVf,WACE,OACE,kBAAC,GAAEhX,UAAH,KACE,kBAAC,GAAD,KACE,kBAAC,GAAD,SCVYiX,QACW,cAA7BvR,OAAOyN,SAAS+D,UAEe,UAA7BxR,OAAOyN,SAAS+D,UAEhBxR,OAAOyN,SAAS+D,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,GAAD,MAAUjU,SAASkU,eAAe,SD6H5C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAA1K,GACLD,QAAQC,MAAMA,EAAM2K,a,+BEzI5B,oEAAO,IAAM7M,EAAa,CACxB,KAAO,EACP,KAAO,EACP,aAAe,EACf,MAAQ,EACR,cAAgB,EAChB,UAAY,GAGD1B,EAAqB,SAAAwO,GAChC,OAAOC,OAAOC,KAAKhN,GAAY1F,MAAK,SAAA2S,GAAS,OAAIjN,EAAWiN,KAAeH,MAAc,S,+BCV3F,6CAQanT,EARb,OAQ4BmH,EAAMoM,cANN,CAC1B7D,WAAY,EACZrG,KAAM,GACNnJ,KAAM,M,+BCLR,kBAGMsT,EACD,GADCA,EAED,GAwICC,EAAQ,CAAE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAKxD,KACbC,aA3ImB,SAACC,EAAIC,GACxB,SAAID,IAAOC,IACID,EAAG/C,WAAU,SAAAiD,GAAC,OAAID,EAAGtJ,QAAQuJ,IAAM,MAC/B,GAyInBC,YAtIkB,SAACH,EAAIC,GAGvB,OADAA,EAAKA,GAAM,IADXD,EAAKA,GAAM,IAED3C,OAAO4C,EAAG5L,QAAO,SAAC+L,GAAD,OAAOJ,EAAGrJ,QAAQyJ,GAAK,OAoIlDC,cAjIoB,SAAA7P,GACpB,MAAO,CACLpF,KAAMoF,EAASrF,EAAI0U,EACnBvU,IAAKkF,EAASnF,EAAIwU,EAClBrU,MAAOgF,EAASrF,EAAI0U,EACpBpU,OAAQ+E,EAASnF,EAAIwU,IA6HvBS,kBAxHwB,SAAA/T,GAExB,OAAOA,EAAK8H,QAAO,SAAAE,GAAC,OAAIA,EAAEtD,SAAWyB,IAAWoL,SAAO/R,KAAI,SAAAwI,GAAC,MAAK,CAC/D5D,QAAS4D,EAAE5D,QACX6M,OAAQrI,IAAWkL,cAAc9L,EAAE/D,eAqHrC+P,YAjHkB,SAACC,EAAIC,GACvB,OAAOD,EAAGlV,KAAOmV,EAAGhV,QAAU+U,EAAG/U,QAAUgV,EAAGnV,KAAOkV,EAAGpV,MAAQqV,EAAGjV,OAASgV,EAAGhV,OAASiV,EAAGrV,MAiH3FsV,cA7GoB,SAAAC,GAIpB,IAHA,IAAMC,EAAa,GAGXV,EAAI,EAAGA,EAAIS,EAAY7U,OAAQoU,IACrC,IAAI,IAAIE,EAAIF,EAAI,EAAGE,EAAIO,EAAY7U,OAAQsU,IACtCjL,IAAWoL,YAAYI,EAAYT,GAAG1C,OAAQmD,EAAYP,GAAG5C,SAC9DoD,EAAWzJ,KAAK,CAACwJ,EAAYT,GAAGvP,QAASgQ,EAAYP,GAAGzP,UAK9D,OAAOiQ,GAkGPC,gBAtDsB,SAAAC,GACtB,IAAIA,GAA8C,IAA3BA,EAAgBhV,OAAc,MAAO,GAI5D,IAFA,IAAIQ,EAAS,GACTyU,EAAsBD,EAAgBE,QACpCD,EAAoBjV,OAAS,GAAE,CAEnC,IAAMmV,EAAW9L,IAAW+L,oBAAoB5U,EAAQyU,GACxDzU,EAAS2U,EAAS3U,OAClByU,EAAsBE,EAASL,WAGjC,OAAOtU,GA2CP6U,mBAhGyB,SAAC7U,EAAQ8U,GAClC,OAAO9U,EAAO2Q,WAAU,SAAAlQ,GAAK,OAAKA,EAAM4J,QAAQyK,EAAU,KAAO,GAAKrU,EAAM4J,QAAQyK,EAAU,KAAO,MAgGrGpE,WAnCiB,SAACzQ,GAClB,IAAMoU,EAAcxL,IAAWmL,kBAAkB/T,GAC3CqU,EAAazL,IAAWuL,cAAcC,GAE5C,OADkBxL,IAAW0L,gBAAgBD,IAiC7CM,oBApF0B,SAAC5U,EAAQsU,GAInC,IAHA,IAAIS,GAAa,EAGTpV,EAAI2U,EAAW9U,OAAS,EAAGG,GAAK,EAAGA,IAAI,CAC7C,IAAMqV,EAAgBnM,IAAWgM,mBAAmB7U,EAAQsU,EAAW3U,IAClD,IAAlBK,EAAOR,QACRQ,EAAO6K,KAAKyJ,EAAW3U,IACvB2U,EAAWW,OAAOtV,EAAG,GACrBoV,GAAa,GACLC,GAAiB,IACzBhV,EAAOgV,GAAiBnM,IAAWgL,YAAY7T,EAAOgV,GAAgBV,EAAW3U,IACjF2U,EAAWW,OAAOtV,EAAG,GACrBoV,GAAa,GAQjB,OAJIA,GAAcT,EAAW9U,OAAS,GACpCQ,EAAO6K,KAAKyJ,EAAWA,EAAW9U,OAAS,IAGtC,CACLQ,OAAQA,EACRsU,WAAYA,IA8DdY,cA7BoB,SAAC3Q,GACrB,OAAOA,GACL,KAAM,EAAG,OAAO,KAChB,KAAK,EAAG,MAAO,SACf,KAAK,EAAG,MAAO,OACf,KAAK,EAAG,MAAO,QACf,KAAK,EAAG,MAAO,SACf,KAAK,EAAG,MAAO,MACf,KAAK,EAAG,MAAO,OACf,QAAS,MAAO,UAqBlBnD,cAhBoB,SAAAmD,GACpB,OAAOiP,EAAMjP,IAAa,O,0CChItB4Q,EAAgB,SAAEtX,EAAUoC,GAChC,IAAMnC,EAJa,SAACD,EAAUoC,GAAX,OAAoBpC,EAAS4B,KAAI,SAAC4E,GAAD,OAAapE,EAAKS,MAAK,SAAAsH,GAAC,OAAIA,EAAE3D,UAAYA,QAIhF+Q,CAAavX,EAAUoC,GAEjCoV,EAAY,GACZC,EAAkB,GAqBtB,OApBAxX,EAAMM,SAAQ,SAAA6J,GACZA,EAAEpD,KAAK7G,KAAKI,SAAQ,SAAAmX,GAClB,IAtBeC,EAOGC,EAeZrE,EAAWiE,EAAU1E,WAAU,SAAAjR,GAAC,OAAIA,EAAEpC,MAAQiY,EAAMjY,OACvD8T,GAAY,EAIViE,EAAUjE,GAAU7T,QAAUgY,EAAMhY,MACrC8X,EAAUjE,IArBIqE,EAqBuBJ,EAAUjE,GArBlC,YAAC,eACnBqE,GADkB,IAErB7X,MAAO6X,EAAQ7X,MAAQ,MAuB4B,IAAxC0X,EAAgBjL,QAAQkL,EAAMjY,MAAagY,EAAgBzK,KAAK0K,EAAMjY,KAG3E+X,EAAUxK,KAnCgB,CAChCvN,KADmBkY,EAmCeD,GAlCpBjY,IACdC,MAAOiY,EAASjY,MAChBE,MAAO+X,EAAS/X,MAChBG,MAAO,UAoCAyX,EACJtN,QAAO,SAAA2N,GAAE,OA5BOC,EA4BUD,EAAGpY,KAAKgY,EA5BMM,MAAK,SAAAC,GAAC,OAAIA,IAAMF,KAAzC,IAACA,KA6BhB5N,QAAO,SAAA2N,GAAE,OAAIA,EAAG9X,QAAUC,EAAS2B,WAGlCsW,EAAuB,SAACC,EAAW9V,GAAZ,OAC3B8V,EAAUtW,KAAI,SAAAuW,GACZ,IAAMC,EAAQhW,EAAKS,MAAK,SAAAuH,GAAC,OAAIA,EAAE5D,UAAY2R,KAC3C,OAAO,2BACFC,EAAMpR,MADX,IAEEL,MAAOyR,EAAMzR,WAEd0R,MAAK,SAACtC,EAAEE,GAAH,OAAUF,EAAEpP,MAAQsP,EAAEtP,MAAS,GAAK,MAmB/B,KACbiJ,eAJqB,SAAApN,GAAc,OAAIA,EAAe8V,QAAQ,SAAC3I,EAAY4I,GAAb,OAA0BA,EAAS3Y,MAAQ+P,IAAa,IAKtHE,aAJmB,SAACF,EAAY6I,GAAb,OAA6BA,EAAa,GAAK1M,KAAK2M,MAAM9I,EAAa6I,IAAgB,GAK1G7V,mBAnByB,SAACR,EAAQC,GAAT,OAAkBD,EAAOP,KAAI,SAACmR,EAAG2F,GAC1D,IAAMlB,EAAYF,EAAcvE,EAAG3Q,GAEnC,MAAO,CACLtC,IAAK4Y,EACL1Y,SAAU+S,EACV1P,YAAa4U,EAAqBlF,EAAG3Q,GACrCrC,MAAOgT,EAAEpR,OACTxB,KAAMqX,EACNtX,SAAUsX,EAAUc,QAAQ,SAAC3I,EAAYxP,GAAb,OAAsBwP,EAAaxP,EAAKP,QAAQ,GAC5EA,MAAO4X,EAAUc,QAAQ,SAAC3I,EAAYxP,GAAb,OAAsBwP,EAAcxP,EAAKJ,MAAQI,EAAKP,QAAS,W","file":"static/js/main.b83cf157.chunk.js","sourcesContent":["import React, { useContext, useMemo, useState, useEffect } from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport { StoreContext } from '../../../store/context';\r\nimport StackHelper from '../../../store/helpers/stack';\r\nimport MetaHelper from '../../../store/helpers/meta';\r\nimport { getColor, mixinFontFamily } from '../../../themes/index';\r\n\r\n// import InfoCard from '../../../components/card/infocard';\r\n\r\nconst S = {};\r\n\r\nS.Container = styled.div`\r\n  pointer-events:none;\r\n  ${'' /* position:absolute; */}\r\n  ${'' /* right:0; */}\r\n  ${'' /* top:25%; */}\r\n  ${'' /* height:50%; */}\r\n  ${'' /* width:300px; */}\r\n`;\r\n\r\n\r\n// S.StackEntry = styled.div`\r\n//   position:absolute;\r\n//   right:2rem;\r\n//   bottom:2rem;\r\n  \r\n//   width:40rem;\r\n//   height:20rem;\r\n// `;\r\n\r\n\r\n// S.Container = styled.div`\r\n//   pointer-events:none;\r\n// `;\r\n\r\nS.Bg = styled.div`\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  z-index:-1;\r\n`;\r\n\r\nS.BgShape = styled.div`\r\n  position:absolute;\r\n  left:0;\r\n  top:0;\r\n  width:60rem;\r\n  height:60rem;\r\n  border: 2rem solid ${getColor('white')};\r\n  background-color:${getColor('blue')};\r\n  border-radius: 50%;\r\n\r\n  &:hover{\r\n    box-shadow: 0 0 1rem .2rem ${getColor('white')};\r\n  }\r\n`;\r\n\r\nS.BgText = styled.img`\r\n  position:absolute;\r\n  left:4rem;\r\n  top:4rem;\r\n  right:0;\r\n  bottom:0;\r\n  width: 324px;\r\n  height: 242px;\r\n  z-index:1;\r\n  pointer-events:none;\r\n`;\r\n\r\nS.StackEntryDivider = styled.hr`\r\n  border-color: ${getColor('white')};\r\n  width: 50%;\r\n  padding:0;\r\n  margin:0 auto;\r\n`;\r\n\r\nS.StackEntryFooter = styled.div`\r\n  margin-top:1.5rem;\r\n  height:4rem;\r\n  width:100%;\r\n  display:flex;\r\n  align-items:baseline;\r\n\r\n  >div{\r\n    height:100%;\r\n  }\r\n`;\r\n\r\nS.SubScore = styled.div`\r\n  flex:1;\r\n`;\r\n\r\nS.SubScoreValue = styled.span`\r\n  font-size: 3rem;\r\n  color: ${getColor('ui_blue')};\r\n`;\r\n\r\nS.SubScoreMultiplier = styled.div`\r\n  >span{\r\n    &:nth-child(1){\r\n    color: ${getColor('ui_green')};\r\n    }\r\n    &:nth-child(2){\r\n      color: ${getColor('white')};\r\n    }\r\n  }\r\n`;\r\n\r\nS.TotalScore = styled.div`\r\n  text-align:left;\r\n  margin-left:.5rem;\r\n  white-space:nowrap;\r\n\r\n  >span{\r\n    &:nth-child(1){\r\n      font-size: 2rem;\r\n      line-height: 2rem;\r\n      color: ${getColor('white')};\r\n    }\r\n    &:nth-child(2){\r\n      font-size: 5rem;\r\n      line-height: 4rem;\r\n      color: ${getColor('ui_yellow')};\r\n      text-shadow: 2px 2px 4px ${getColor('black')};\r\n    }\r\n  }\r\n`;\r\n\r\nS.StackPreview = styled.div`\r\n  display:inline-block;\r\n  vertical-align:bottom;\r\n  width:35%;\r\n  height:100%;\r\n\r\n  position:relative;\r\n`;\r\n\r\nS.StackPreviewCenterer = styled.ul`\r\n  list-style:none;\r\n  padding:0;\r\n  margin:0;\r\n\r\n  position: absolute;\r\n  right: -2rem;\r\n  bottom: 25%;\r\n  transform: translate(-50%, -50%);\r\n`;\r\n\r\nS.StackMeta = styled.ul`\r\n  display:inline-block;\r\n  vertical-align:bottom;\r\n  width:65%;\r\n\r\n  list-style:none;\r\n  margin:0;\r\n  padding:0;\r\n`;\r\n\r\nS.NoMeta = styled.li`\r\n  span{\r\n\r\n  }\r\n`;\r\n\r\nS.MetaLine = styled.li`\r\n  >div{\r\n    display:inline-block;\r\n    vertical-align:top;\r\n  }\r\n`;\r\n\r\nS.MetaLineLeft = styled.div`\r\n  width:40%;\r\n  text-align:right;\r\n\r\n  span{\r\n    font-size:3rem;\r\n    line-height:4rem;\r\n    color:${getColor('ui_blue')};\r\n  }\r\n`;\r\n\r\nS.MetaLineRight = styled.div`\r\n  width:60%;\r\n  text-align:left;\r\n  font-size:3rem;\r\n  padding-left:1rem;\r\n`;\r\n\r\nS.MetaTag = styled.p`\r\n  font-size:1rem;\r\n  margin-bottom:-1rem;\r\n  color:${getColor('white')};\r\n`;\r\nS.MetaValue = styled.p`\r\n  font-size:2rem;\r\n  color:${getColor('ui_green')};\r\n`;\r\n\r\n\r\n// S.StackEntry = styled.div`\r\n//   list-style:none;\r\n//   position:relative;\r\n//   border:5px solid white;\r\n// `;\r\n\r\nS.StackEntry = styled.div`\r\n  position:absolute;\r\n  padding:20px;\r\n  margin-left: 40px;\r\n  \r\n  opacity:0;\r\n  &.showing{\r\n    opacity:1;\r\n    transition: opacity .5s;\r\n  }\r\n\r\n  \r\n`;\r\nS.StackDetailsBg = styled.div`\r\n  position:absolute;\r\n  width:100%;\r\n  height:100%;\r\n  left:0;\r\n  top:0;\r\n  border-left:0;\r\n\r\n  border-radius: 10px;\r\n  background-color: ${getColor('blue')};\r\n  border: 10px solid white;\r\n  z-index:-1;\r\n`\r\n\r\n\r\nS.Cards = styled.div`\r\n  position:absolute;\r\n  right:100%;\r\n  top:50%;\r\n`;\r\n\r\nS.Details = styled.div`\r\n  text-align:left;\r\n`;\r\n\r\nS.Total = styled.div`\r\n`;\r\n\r\nconst getStackBounds = (stackIdxs) => {\r\n  let stackBounds = [null, null];\r\n\r\n  stackIdxs.forEach(idx => {\r\n    let element = global.document.querySelector(`#card-${idx}`);\r\n    if(element && element.children[0]){\r\n      let eleBox = element.children[0]; //actual card that takes up space\r\n      let rect = eleBox.getBoundingClientRect();\r\n      let upperLeft = { x: rect.left, y: rect.top };\r\n      let lowerRight = { x: rect.right, y: rect.bottom };\r\n      if(!stackBounds[0]){\r\n        stackBounds[0] = upperLeft;\r\n      }else{\r\n        if(upperLeft.x < stackBounds[0].x) stackBounds[0].x = upperLeft.x;\r\n        if(upperLeft.y < stackBounds[0].y) stackBounds[0].y = upperLeft.y;\r\n      }\r\n      if(!stackBounds[1]){\r\n        stackBounds[1] = lowerRight;\r\n      }else{\r\n        if(lowerRight.x > stackBounds[1].x) stackBounds[1].x = lowerRight.x;\r\n        if(lowerRight.y > stackBounds[1].y) stackBounds[1].y = lowerRight.y;\r\n      }\r\n    }\r\n  })\r\n\r\n  // console.log('returning stackBounds', stackBounds);\r\n  return stackBounds;\r\n}\r\n\r\nconst makeLittleCards = cards => {\r\n    const xDelta = 25;\r\n    const degDelta = 10;\r\n    const yDelta = 3;\r\n    const startX = 0 - (cards.length * xDelta);\r\n    const startDeg = 0 - (cards.length * degDelta) / 2;\r\n    const halfIdx = Math.floor(cards.length / 2);\r\n  \r\n    return cards.map((c, cIdx) => {\r\n      const x = startX + (cIdx * xDelta);\r\n      const deg = startDeg + (cIdx * degDelta);\r\n      const y = Math.abs(halfIdx - cIdx) * yDelta;\r\n      const translateString = `translate(${x}px, ${y}px) rotate(${deg}deg)`;\r\n      return (\r\n        <li key={cIdx} style={{transform: translateString}}>\r\n          {/* <InfoCard data={c} /> */}\r\n        </li>\r\n      )\r\n    })\r\n  }\r\n  \r\n  function MetaLine({ data }){\r\n    return (\r\n      <S.MetaLine>\r\n        <S.MetaLineLeft>\r\n          <S.MetaTag>{`${data.tag}`}</S.MetaTag>\r\n          <S.MetaValue>{data.value.toString()}</S.MetaValue>\r\n        </S.MetaLineLeft>\r\n        <S.MetaLineRight>\r\n          <span>{data.score}</span>\r\n        </S.MetaLineRight>\r\n      </S.MetaLine>\r\n    )\r\n  }\r\n  \r\n\r\n\r\nfunction StackEntry({ label, idx, count, cards, cardIdxs, score, subScore, meta, isShowing }) {\r\n  let xPos = 0;\r\n  let yPos = 0;\r\n  // console.log('cards', cards)\r\n\r\n  let stackBounds = getStackBounds(cardIdxs);\r\n  let cssBox = {};\r\n  if(stackBounds && stackBounds[0]){\r\n    cssBox = {\r\n      // left: stackBounds[0].x,\r\n      // top: stackBounds[0].y,\r\n      // width: stackBounds[1].x - stackBounds[0].x,\r\n      // height: stackBounds[1].y - stackBounds[0].y,\r\n      left: stackBounds[1].x,\r\n      top: stackBounds[0].y,\r\n      // height: stackBounds[1].y - stackBounds[0].y,\r\n    }\r\n  }\r\n\r\n  return (\r\n    <S.StackEntry \r\n      style={ cssBox }\r\n      className={ isShowing ? 'showing' : 'hidden' } >\r\n      {/* <S.Cards>\r\n        { makeLittleCards(cards) }\r\n      </S.Cards> */}\r\n      <S.Details>\r\n        {meta.length > 0 ? (\r\n          <S.StackMeta>\r\n            {meta.map((m, i) => <MetaLine key={i} data={m} />)}\r\n          </S.StackMeta>\r\n        ):(\r\n          <S.StackMeta>\r\n            <S.NoMeta><span>{'no matching tags'}</span></S.NoMeta>\r\n          </S.StackMeta>\r\n        )}\r\n      </S.Details>\r\n      <S.Total>\r\n        <span>{count}</span>\r\n        <span>{` cards x `}</span>\r\n        <S.SubScoreValue>{subScore}</S.SubScoreValue>\r\n\r\n        <span>{'= '}</span>\r\n        <span>{score}</span>\r\n      </S.Total>\r\n      <S.StackDetailsBg />\r\n    </S.StackEntry>\r\n  );\r\n}\r\n\r\n// function StackConsole() {\r\n//   const { stacks, hand } = useContext(StoreContext);\r\n//   const completeStacks = useMemo(() => \r\n//     MetaHelper.calcCompleteStacks(stacks, hand),\r\n//     [ stacks, hand ]\r\n//   );\r\n\r\n//   console.log('completStacks is ', completeStacks)\r\n  \r\n\r\n//   return (\r\n//     <S.Container id=\"stack-data-container\">\r\n//       {completeStacks.map((stack,idx) => (\r\n//         <StackEntry \r\n//             key={`stack-${idx}`}\r\n//             cards={stack.cardDetails}\r\n//             cardIdxs={stack.cardIdxs}\r\n//             idx={stack.idx}\r\n//             label={ StackHelper.getStackLabel(stack.idx) }\r\n//             count={stack.count}\r\n//             score={stack.score}\r\n//             subScore={stack.subScore}\r\n//             meta={stack.meta} />\r\n//       ))}\r\n//     </S.Container>\r\n//   );\r\n// }\r\n\r\nvar timer;\r\n\r\nfunction StackConsole() {\r\n  const { stacks, hand, focusedStackIdx } = useContext(StoreContext);\r\n  const [ isShowing, setIsShowing ] = useState(false);\r\n\r\n  const completeStacks = useMemo(() => \r\n    MetaHelper.calcCompleteStacks(stacks, hand),\r\n    [ stacks, hand ]\r\n  );\r\n\r\n  const stack = useMemo(() => \r\n    completeStacks.find(stack => stack.idx === focusedStackIdx),\r\n    [ completeStacks, focusedStackIdx ]\r\n  );\r\n\r\n\r\n  /* whatever im doing here is bullshit, redo this tooltip type thing */\r\n  function startTimeout(callback){\r\n    killTimer();\r\n    timer = window.setTimeout(callback, 1);\r\n  }\r\n\r\n  function killTimer(){\r\n    if(timer){\r\n      window.clearTimeout(timer);\r\n      timer = null;\r\n    }\r\n  }\r\n\r\n  useEffect(() => {\r\n    if(stack){\r\n      if(focusedStackIdx !== stack.idx){\r\n        setIsShowing(false);\r\n      }else{\r\n        if(!isShowing){\r\n          startTimeout(() => {\r\n            setIsShowing(true);\r\n          })\r\n        }\r\n      }\r\n    }else{\r\n      setIsShowing(false);\r\n    }\r\n  },\r\n  [ stack, isShowing, focusedStackIdx, setIsShowing ]);\r\n\r\n  return (\r\n    <S.Container id=\"stack-data-container\" >\r\n      {stack && (\r\n        <StackEntry \r\n          isShowing={isShowing}\r\n          cards={stack.cardDetails}\r\n          cardIdxs={stack.cardIdxs}\r\n          idx={stack.idx}\r\n          label={ StackHelper.getStackLabel(stack.idx) }\r\n          count={stack.count}\r\n          score={stack.score}\r\n          subScore={stack.subScore}\r\n          meta={stack.meta} />\r\n      )}\r\n    </S.Container>\r\n  );\r\n}\r\n\r\n\r\nexport default StackConsole;\r\n","import { css } from 'styled-components';\n\nexport const themeGet = (...args) => props => {\n  let current = props.theme;\n  for (const arg of args) {\n    if (!current[arg]) {\n      console.error('[Theming] Could not find', arg, 'in', current);\n      return '';\n    }\n    current = current[arg];\n  }\n  return current;\n};\n\nexport const mixinFontFamily = (style) => {\n  switch(style){\n    case 'details' : return css`font-family: 'Roboto', sans-serif`;\n    case 'display': return css`font-family: 'Bevan', cursive`;\n    default: return css`font-family: 'Roboto', sans-serif`;\n  }\n}\n\n/* MIXINS */\nexport const mixin_clearBubble = () => {\n  return css`\n    border: .2rem solid rgba(255, 255, 255, 0.2);\n    border-color: rgba(255, 255, 255, 0.2) rgba(0, 0, 0, 0.2) rgba(0, 0, 0, 0.2) rgba(255, 255, 255, 0.2);\n    border-radius: 1rem;\n    box-shadow: .1rem .1rem .5rem black;\n  `;\n}\n\nexport const mixin_textStroke = (thickness, spread, color) => {\n  return css`\n    text-shadow:  -${thickness} -${thickness} ${spread} ${color},\n                  ${thickness} -${thickness} ${spread} ${color},\n                  -${thickness} ${thickness} ${spread} ${color},\n                  ${thickness} ${thickness} ${spread} ${color},\n                  -${thickness} -${thickness} ${spread} ${color},\n                  ${thickness} -${thickness} ${spread} ${color},\n                  -${thickness} ${thickness} ${spread} ${color},\n                  ${thickness} ${thickness} ${spread} ${color},\n                  -${thickness} -${thickness} ${spread} ${color},\n                  ${thickness} -${thickness} ${spread} ${color},\n                  -${thickness} ${thickness} ${spread} ${color},\n                  ${thickness} ${thickness} ${spread} ${color},\n                  -${thickness} -${thickness} ${spread} ${color},\n                  ${thickness} -${thickness} ${spread} ${color},\n                  -${thickness} ${thickness} ${spread} ${color},\n                  ${thickness} ${thickness} ${spread} ${color};\n  `;\n}\n\n\n/* COLORS */\nexport const listColors = () => {\n  return Object.keys(store.color);\n}\n\nexport const getColor = (colorId) => {\n  return store.color[colorId];\n}\n\nexport const getShadow = (shadowId) => {\n  return store.shadow[shadowId];\n}\n\n\n/* from pablo on https://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors */\nexport const shadeColor = (colId, percent) => {\n  var color = store.color[colId] || colId;\n\n  var R = parseInt(color.substring(1,3),16);\n  var G = parseInt(color.substring(3,5),16);\n  var B = parseInt(color.substring(5,7),16);\n\n  R = parseInt(R * (100 + percent) / 100);\n  G = parseInt(G * (100 + percent) / 100);\n  B = parseInt(B * (100 + percent) / 100);\n\n  R = (R<255)?R:255;  \n  G = (G<255)?G:255;  \n  B = (B<255)?B:255;  \n\n  var RR = ((R.toString(16).length===1)?\"0\"+R.toString(16):R.toString(16));\n  var GG = ((G.toString(16).length===1)?\"0\"+G.toString(16):G.toString(16));\n  var BB = ((B.toString(16).length===1)?\"0\"+B.toString(16):B.toString(16));\n\n  return \"#\"+RR+GG+BB;\n}\n\n/* BREAKPOINTS */\n/* https://jsramblings.com/how-to-use-media-queries-with-styled-components/ */\nconst breakpoints = {\n  mobile_tiny: '300px',\n  mobile_medium: '400px',\n  mobile_large: '500px',\n  tablet: '768px',\n  desktop: '1024px'\n}\n\nexport const getBreakpoint = {\n  mobile_tiny: `(min-width: ${breakpoints.mobile_tiny})`,\n  mobile_medium: `(min-width: ${breakpoints.mobile_medium})`,\n  mobile_large: `(min-width: ${breakpoints.mobile_large})`,\n  tablet: `(min-width: ${breakpoints.tablet})`,\n  desktop: `(min-width: ${breakpoints.desktop})`\n};\n\nconst store = {\n  color:{\n    black: '#000000',\n    grey: '#373737',\n    grey_light: '#A39F8E',\n    white: '#ffffff',\n    blue: '#225C87',\n    green: '#238845',\n    yellow: '#688722',\n    orange: '#688722',\n    purple: '#5E238C',\n    pink: '#85227E',\n    ui_blue: '#20F3FF',\n    ui_orange: '#FD9410',\n    ui_yellow: '#FDE010',\n    ui_green: '#10FD21',\n  },\n  shadow:{\n    z1: '-0.1rem 0.1rem .25rem .1rem rgba(0,0,0,0.16)',\n    z2: '-0.1rem 0.1rem .25rem .1rem rgba(0,0,0,0.36)',\n    z3: '-.2rem .5rem 1rem .2rem rgba(0,0,0,.36)'\n  },\n  value:{\n    headerHeight: '7.5rem',\n    menuWidth: '12rem'\n  },\n  mixins:{},\n  breakpoints:{\n    mobile_tiny: '300px',\n    mobile_medium: '400px',\n    mobile_large: '500px',\n    tablet: '768px',\n    desktop: '1024px'\n  }\n}\n\nexport default store;\n","import React from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport { mixin_textStroke, getShadow, getColor } from '../../themes/index';\r\n// import InnerCard from './inner-card';\r\nimport { getCardStatusLabel } from '../../utils/constants';\r\n\r\nconst S = {};\r\n\r\nS.Card = styled.div`\r\n  background-color: ${p => p.theme || 'white'};\r\n  border-radius:1rem;\r\n  color:black;\r\n  cursor:pointer;\r\n  z-index: ${p => p.depth};\r\n  ${p => p.isDragging && css`\r\n    z-index:1000;\r\n  `}\r\n\r\n  ${p => p.inHand ? css`\r\n    display:inline-block;\r\n    position:relative;\r\n    width:10rem;\r\n    height:15rem;\r\n    top:-5rem;\r\n  `:css`\r\n    position:absolute;\r\n  `}\r\n`;\r\n\r\nS.InnerCard = styled.div`\r\n  position:absolute;\r\n  width:10rem;\r\n  height:15rem;\r\n  transform-origin: 50% 50%;\r\n  ${p => p.inHand ? css`\r\n    left: 0;\r\n    top: 0;\r\n  `:css`\r\n    left: -5rem;\r\n    top: -7.5rem;\r\n  `}\r\n  \r\n  transition: transform .3s cubic-bezier(1,.05,.32,1.2), opacity .3s;\r\n  border-radius: 1rem;\r\n  \r\n  box-shadow: ${getShadow('z3')};\r\n  ${p => p.stackStyle === 'stacked' && css`\r\n    box-shadow: 1px 3px 2px 4px ${getColor('ui_blue')};\r\n  `}\r\n  ${p => p.stackStyle === 'focused' && css`\r\n    box-shadow: 1px 3px 2px 4px ${getColor('ui_green')};\r\n  `}\r\n\r\n  ${p => p.isDragging && css`\r\n    transform: scaleX(1.5) scaleY(1.5);\r\n    opacity: .5;\r\n    transition: transform .1s cubic-bezier(.42,.05,.86,.13), opacity .2s;\r\n  `}\r\n`;\r\n\r\nS.Background = styled.img`\r\n  background-size: contain;\r\n  width:100%;\r\n  height:100%;\r\n  border-radius:1rem;\r\n`;\r\n\r\nS.DebugStatus = styled.p`\r\n  color:white;\r\n  position:absolute;\r\n  bottom:100%;\r\n`\r\n\r\nfunction AbstractCard({ onMouseDown, onMouseOver, position, cardRef, stackStyle, dragPosition, inHand, data, theme='white' }) {\r\n  return (\r\n    <S.Card\r\n      id={`card-${data.cardIdx}`} \r\n      theme={theme} \r\n      isDragging={!!dragPosition}\r\n      onMouseDown={e => onMouseDown(e, data.cardIdx)}\r\n      onMouseOver={e => onMouseOver(e, data.cardIdx, data.stackIdx)}\r\n      depth={data.layer}\r\n      ref={cardRef}\r\n      inHand={inHand}\r\n      style={inHand ? null : {\r\n        left: `${position.x}px`,\r\n        top: `${position.y}px`,\r\n      }}\r\n    >\r\n      <S.InnerCard \r\n        isDragging={!!dragPosition}\r\n        inHand={inHand}\r\n        stackStyle={stackStyle}\r\n      >\r\n        <S.DebugStatus>{getCardStatusLabel(data.status)}</S.DebugStatus>\r\n        <S.Background src={data.info.imageUrl} draggable={false} />\r\n      </S.InnerCard>\r\n    </S.Card>\r\n  );\r\n}\r\n\r\nexport default AbstractCard;\r\n","import React, { useState, useEffect, useContext, useCallback, useRef, useMemo } from 'react';\r\nimport { StoreContext } from '../../store/context';\r\nimport { CARDSTATUS } from '../../utils/constants';\r\nimport Card from './card';\r\n\r\nconst S = {};\r\n\r\nfunction usePosition(restingPosition, dragPosition, status){\r\n  if(status === CARDSTATUS.HAND){\r\n    return {\r\n      x: 0,\r\n      y: 0\r\n    }\r\n  }\r\n\r\n  if(!!dragPosition){\r\n    return {\r\n      x: dragPosition.x,\r\n      y: dragPosition.y\r\n    }\r\n  }else{\r\n    return {\r\n      x: restingPosition.x,\r\n      y: restingPosition.y\r\n    }\r\n  }\r\n}\r\n\r\nfunction ActiveCard({ data, theme='white' }) {\r\n  const { actions, focusedStackIdx } = useContext(StoreContext);\r\n\r\n  const [ state, setState ] = useState({\r\n    dragPosition: null,\r\n    activeListener: false\r\n  });\r\n\r\n  const cardRef = useRef(null);\r\n  \r\n  const onMouseOver = useCallback((e, cardIdx, stackIdx) => {\r\n    actions.setFocusedCardIdx(cardIdx);\r\n    actions.setFocusedStackIdx(stackIdx);\r\n  }, [ actions.setFocusedStackIdx, actions.setFocusedCardIdx ]);\r\n\r\n  const onMouseDown = useCallback(({ clientX, clientY }, cardIdx) => {\r\n    actions.holdCard(cardIdx);\r\n\r\n    setState(state => ({\r\n      ...state,\r\n      activeListener: true,\r\n      dragPosition: {\r\n        x: clientX,\r\n        y: clientY\r\n      }\r\n    }));\r\n  }, [ actions.holdCard ]);\r\n\r\n  const onMouseDraggingCard = useCallback(({ clientX, clientY }) => {\r\n    // console.log('onMouseDraggingCard')\r\n    setState(state => ({\r\n      ...state,\r\n      dragPosition: {\r\n        x: clientX,\r\n        y: clientY\r\n      }\r\n    }));\r\n\r\n  }, []);\r\n\r\n  const onMouseDroppedCard = useCallback(({ clientX, clientY }) => {\r\n    setState(state => ({\r\n      ...state,\r\n      activeListener: false,\r\n      dragPosition:null\r\n    }));\r\n\r\n    // console.log('simple: mouseDropped', data.cardIdx);\r\n    actions.dropCard(data.cardIdx, 'TABLE', {\r\n      x: clientX,\r\n      y: clientY\r\n    });\r\n\r\n  }, [ data.cardIdx, actions.dropCard ]);\r\n\r\n  useEffect(() => {\r\n    if(state.activeListener){\r\n      cardRef.current.addEventListener('mouseleave', onMouseDroppedCard);\r\n      cardRef.current.addEventListener('mousemove', onMouseDraggingCard);\r\n      cardRef.current.addEventListener('mouseup', onMouseDroppedCard);\r\n    }else {\r\n      cardRef.current.removeEventListener('mouseleave', onMouseDroppedCard);\r\n      cardRef.current.removeEventListener('mousemove', onMouseDraggingCard);\r\n      cardRef.current.removeEventListener('mouseup', onMouseDroppedCard);\r\n    }\r\n  }, [ state.activeListener ]);\r\n\r\n  //- keeps position when selecting card from hand\r\n  useEffect(() => {\r\n    if(!state.initialized){\r\n      setState(state => ({\r\n        ...state,\r\n        activeListener:true,\r\n        dragPosition: {\r\n          x: data.position.x,\r\n          y: data.position.y\r\n        }\r\n      }));\r\n    }\r\n  }, [ state.initialized ]);\r\n\r\n  let position = usePosition(data.position, state.dragPosition, data.status);\r\n\r\n  const stackStyle = useMemo(() => \r\n    {\r\n      if(data.stackIdx === -1){\r\n        return null;\r\n      }else{\r\n        if(focusedStackIdx === data.stackIdx){\r\n          return 'focused';\r\n        }else{\r\n          return 'stacked';\r\n        }\r\n      }\r\n    },\r\n    [ data.stackIdx, focusedStackIdx ]\r\n  );\r\n\r\n  return (\r\n    <Card\r\n      data={data}\r\n      theme={theme} \r\n      onMouseDown={onMouseDown}\r\n      onMouseOver={onMouseOver}\r\n      cardRef={cardRef}\r\n      inHand={false}\r\n      position={position}\r\n      dragPosition={state.dragPosition}\r\n      stackStyle={stackStyle} >\r\n    </Card>\r\n  );\r\n}\r\n\r\nexport default ActiveCard;\r\n","import React, { useContext, useMemo } from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport { StoreContext } from '../../../store/context';\r\nimport StackHelper from '../../../store/helpers/stack';\r\nimport MetaHelper from '../../../store/helpers/meta';\r\nimport { getColor } from '../../../themes/index';\r\n\r\nconst S = {};\r\n\r\nS.Container = styled.div`\r\n  width:15rem;\r\n  min-height:22rem;\r\n  padding:2rem;\r\n`;\r\n\r\nS.BasicButton = styled.div`\r\n  padding: .5rem 1.5rem;\r\n  font-size: 1rem;\r\n  background-color: ${getColor('purple')};\r\n  border-radius: 1rem;\r\n  width: 100%;\r\n  font-weight: bold;\r\n  cursor:pointer;\r\n\r\n  border: .5rem solid ${getColor('white')};\r\n  color:${getColor('white')};\r\n  &:first-child{\r\n    margin-top:0;\r\n  }\r\n  margin-top: .5rem;\r\n\r\n  &:hover{\r\n    background-color: ${getColor('green')};\r\n    /* color:${getColor('blue')}; */\r\n    box-shadow: 0 0 1rem .2rem white;\r\n  }\r\n`;\r\n\r\nS.Bg = styled.div`\r\n  position:absolute;\r\n  z-index:-1;\r\n  left:0;\r\n  top:0;\r\n  right:0;\r\n  bottom:0;\r\n  border-radius: 2rem;\r\n  border: 1rem solid white;\r\n`;\r\n\r\nS.ZoneText = styled.p`\r\n  position:absolute;\r\n  padding-top: 1rem;\r\n  top:100%;\r\n  width:100%;\r\n  left:0;\r\n  text-align:center;\r\n  color:${getColor('white')}\r\n`;\r\n\r\nfunction DrawZone() {\r\n  const { actions } = useContext(StoreContext);\r\n\r\n  return (\r\n    <S.Container >\r\n      <S.BasicButton onClick={() => actions.dealHand()} role=\"button\">\r\n        {'DEAL'}\r\n      </S.BasicButton>\r\n      <S.BasicButton onClick={() => actions.dealCard(1)} role=\"button\">\r\n        {'DRAW 1 MORE'}\r\n      </S.BasicButton>\r\n      <S.BasicButton onClick={() => actions.discardHand()} role=\"button\">\r\n        {'DISCARD ALL'}\r\n      </S.BasicButton>\r\n      <hr/>\r\n      <S.BasicButton onClick={() => actions.dealCard(10)} role=\"button\">\r\n        {'HIT 10'}\r\n      </S.BasicButton>\r\n      <S.BasicButton onClick={() => actions.discardRandomCard()} role=\"button\">\r\n        {'DISCARD RANDOM'}\r\n      </S.BasicButton>\r\n      <S.ZoneText>{'DRAW'}</S.ZoneText>\r\n      <S.Bg />\r\n    </S.Container>\r\n  );\r\n}\r\n\r\nexport default DrawZone;\r\n","import React from 'react';\r\nimport styled, { } from 'styled-components';\r\nimport { StoreContext } from '../../../store/context';\r\n\r\nconst S = {};\r\n\r\nS.Container = styled.div`\r\n  width: 100%;\r\n  height: 100%;\r\n  p{\r\n    opacity:0;\r\n    color: white;\r\n    transition: opacity .1s;\r\n    text-align:left;\r\n    margin-left:1rem;\r\n  }\r\n  transition: box-shadow 1s;\r\n\r\n  &:hover{\r\n    box-shadow: 0 0 1rem .2rem white;\r\n    transition-delay: .5s;\r\n    p{\r\n      opacity:1;\r\n      transition: opacity 1s;\r\n      transition-delay: .7s;\r\n    }\r\n  }\r\n`;\r\n\r\n/* \r\n  TODO, tried this with hooks but couldnt get it to stop doing an infinite re-render with refs and useEffect\r\n*/\r\nclass DropZone extends React.Component{\r\n  static contextType = StoreContext;\r\n\r\n  constructor(props) {\r\n    super(props)\r\n    this.zoneRef = React.createRef();\r\n    this.onWindowResize = this.onWindowResize.bind(this);\r\n  }\r\n\r\n  componentDidMount(){\r\n    window.addEventListener('resize', this.onWindowResize);\r\n    this.context.actions.setZone('hand', this.zoneRef?.current?.getBoundingClientRect());\r\n  }\r\n\r\n  componentWillUnmount(){\r\n    window.removeEventListener('resize', this.onWindowResize);\r\n  }\r\n\r\n  onWindowResize(){\r\n    this.context.actions.setZone('hand', this.zoneRef?.current?.getBoundingClientRect());\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <S.Container \r\n        ref={this.zoneRef} >\r\n        <p>{'Return card to hand'}</p>\r\n      </S.Container>\r\n    )\r\n  };\r\n}\r\n\r\nexport default DropZone;\r\n","import React, { useContext, useMemo } from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport { StoreContext } from '../../../store/context';\r\nimport StackHelper from '../../../store/helpers/stack';\r\nimport MetaHelper from '../../../store/helpers/meta';\r\nimport { getColor, mixinFontFamily } from '../../../themes/index';\r\n\r\n// import InfoCard from '../../../components/card/infocard';\r\n\r\nconst S = {};\r\n\r\nS.Container = styled.div`\r\n  pointer-events:none;\r\n`;\r\n\r\nS.Bg = styled.div`\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  z-index:-1;\r\n`;\r\n\r\nS.BgShape = styled.div`\r\n  position:absolute;\r\n  left:0;\r\n  top:0;\r\n  width:60rem;\r\n  height:60rem;\r\n  border: 2rem solid ${getColor('white')};\r\n  background-color:${getColor('blue')};\r\n  border-radius: 50%;\r\n\r\n  &:hover{\r\n    box-shadow: 0 0 1rem .2rem ${getColor('white')};\r\n  }\r\n`;\r\n\r\nS.BgText = styled.img`\r\n  position:absolute;\r\n  left:4rem;\r\n  top:4rem;\r\n  right:0;\r\n  bottom:0;\r\n  width: 324px;\r\n  height: 242px;\r\n  z-index:1;\r\n  pointer-events:none;\r\n`;\r\n\r\nS.StackEntry = styled.div`\r\n  position:absolute;\r\n  right:2rem;\r\n  bottom:2rem;\r\n  \r\n  width:40rem;\r\n  height:20rem;\r\n`;\r\n\r\nS.StackEntryBody = styled.div`\r\n  height:15rem;\r\n  width:100%;\r\n`;\r\n\r\nS.StackEntryDivider = styled.hr`\r\n  border-color: ${getColor('white')};\r\n  width: 50%;\r\n  padding:0;\r\n  margin:0 auto;\r\n`;\r\n\r\nS.StackEntryFooter = styled.div`\r\n  margin-top:1.5rem;\r\n  height:4rem;\r\n  width:100%;\r\n  display:flex;\r\n  align-items:baseline;\r\n\r\n  >div{\r\n    height:100%;\r\n  }\r\n`;\r\n\r\nS.SubScore = styled.div`\r\n  text-align:right;\r\n  flex:1;\r\n`;\r\n\r\nS.SubScoreValue = styled.span`\r\n  font-size: 3rem;\r\n  color: ${getColor('ui_blue')};\r\n`;\r\n\r\nS.SubScoreMultiplier = styled.div`\r\n  >span{\r\n    &:nth-child(1){\r\n    color: ${getColor('ui_green')};\r\n    }\r\n    &:nth-child(2){\r\n      color: ${getColor('white')};\r\n    }\r\n  }\r\n`;\r\n\r\nS.TotalScore = styled.div`\r\n  text-align:left;\r\n  margin-left:.5rem;\r\n  white-space:nowrap;\r\n\r\n  >span{\r\n    &:nth-child(1){\r\n      font-size: 2rem;\r\n      line-height: 2rem;\r\n      color: ${getColor('white')};\r\n    }\r\n    &:nth-child(2){\r\n      font-size: 5rem;\r\n      line-height: 4rem;\r\n      color: ${getColor('ui_yellow')};\r\n      text-shadow: 2px 2px 4px ${getColor('black')};\r\n    }\r\n  }\r\n`;\r\n\r\nS.StackPreview = styled.div`\r\n  display:inline-block;\r\n  vertical-align:bottom;\r\n  width:35%;\r\n  height:100%;\r\n\r\n  position:relative;\r\n`;\r\n\r\nS.StackPreviewCenterer = styled.ul`\r\n  list-style:none;\r\n  padding:0;\r\n  margin:0;\r\n\r\n  position: absolute;\r\n  right: -2rem;\r\n  bottom: 25%;\r\n  transform: translate(-50%, -50%);\r\n`;\r\n\r\nS.StackMeta = styled.ul`\r\n  display:inline-block;\r\n  vertical-align:bottom;\r\n  width:65%;\r\n\r\n  list-style:none;\r\n  margin:0;\r\n  padding:0;\r\n`;\r\n\r\nS.NoMeta = styled.li`\r\n  span{\r\n\r\n  }\r\n`;\r\n\r\nS.MetaLine = styled.li`\r\n  >div{\r\n    display:inline-block;\r\n    vertical-align:bottom;\r\n  }\r\n`;\r\n\r\nS.MetaLineLeft = styled.div`\r\n  width:40%;\r\n  text-align:right;\r\n\r\n  span{\r\n    font-size:3rem;\r\n    line-height:4rem;\r\n    color:${getColor('ui_blue')};\r\n  }\r\n`;\r\n\r\nS.MetaLineRight = styled.div`\r\n  width:60%;\r\n  text-align:left;\r\n  padding-left:1rem;\r\n`;\r\n\r\nS.MetaTag = styled.p`\r\n  font-size:1rem;\r\n  margin-bottom:-1rem;\r\n  color:${getColor('white')};\r\n`;\r\nS.MetaValue = styled.p`\r\n  font-size:2rem;\r\n  color:${getColor('ui_green')};\r\n`;\r\n\r\nconst makeLittleCards = cards => {\r\n  const xDelta = 25;\r\n  const degDelta = 10;\r\n  const yDelta = 3;\r\n  const startX = 0 - (cards.length * xDelta);\r\n  const startDeg = 0 - (cards.length * degDelta) / 2;\r\n  const halfIdx = Math.floor(cards.length / 2);\r\n\r\n  return cards.map((c, cIdx) => {\r\n    const x = startX + (cIdx * xDelta);\r\n    const deg = startDeg + (cIdx * degDelta);\r\n    const y = Math.abs(halfIdx - cIdx) * yDelta;\r\n    const translateString = `translate(${x}px, ${y}px) rotate(${deg}deg)`;\r\n    return (\r\n      <li key={cIdx} style={{transform: translateString}}>\r\n        {/* <InfoCard data={c} /> */}\r\n      </li>\r\n    )\r\n  })\r\n}\r\n\r\nfunction MetaLine({ data }){\r\n  return (\r\n    <S.MetaLine>\r\n      <S.MetaLineLeft><span>{data.score}</span></S.MetaLineLeft>\r\n      <S.MetaLineRight>\r\n        <S.MetaTag>{`${data.tag}`}</S.MetaTag>\r\n        <S.MetaValue>{data.value.toString()}</S.MetaValue>\r\n      </S.MetaLineRight>\r\n    </S.MetaLine>\r\n  )\r\n}\r\n\r\nfunction StackEntry({ label, idx, count, cards, score, subScore, meta }) {\r\n  return (\r\n    <S.StackEntry>\r\n      <S.StackEntryBody>\r\n        <S.StackPreview>\r\n          <S.StackPreviewCenterer>\r\n            { makeLittleCards(cards) }\r\n          </S.StackPreviewCenterer>\r\n        </S.StackPreview>\r\n        {meta.length > 0 ? (\r\n          <S.StackMeta>\r\n            {meta.map((m, i) => <MetaLine key={i} data={m} />)}\r\n          </S.StackMeta>\r\n        ):(\r\n          <S.StackMeta>\r\n            <S.NoMeta><span>{'no matching tags'}</span></S.NoMeta>\r\n          </S.StackMeta>\r\n        )}\r\n        <S.StackEntryDivider/>\r\n      </S.StackEntryBody>\r\n      <S.StackEntryFooter>\r\n        <S.SubScore>\r\n          <S.SubScoreMultiplier>\r\n            <span>{count}</span>\r\n            <span>{` cards x `}</span>\r\n          </S.SubScoreMultiplier>\r\n          <S.SubScoreValue>{subScore}</S.SubScoreValue>\r\n        </S.SubScore>\r\n        <S.TotalScore>\r\n          <span>{'= '}</span>\r\n          <span>{score}</span>\r\n        </S.TotalScore>\r\n      </S.StackEntryFooter>\r\n    </S.StackEntry>\r\n  );\r\n}\r\n\r\nfunction StackInfo() {\r\n  const { stacks, hand, focusedStackIdx } = useContext(StoreContext);\r\n  const completeStacks = useMemo(() => \r\n    MetaHelper.calcCompleteStacks(stacks, hand),\r\n    [ stacks, hand ]\r\n  );\r\n\r\n  const stack = useMemo(() => \r\n    completeStacks.find(stack => stack.idx === focusedStackIdx),\r\n    [ completeStacks, focusedStackIdx ]\r\n  );\r\n\r\n  return (\r\n    <S.Container >\r\n      {stack && (\r\n        <StackEntry \r\n          cards={stack.cardDetails}\r\n          idx={stack.idx}\r\n          label={ StackHelper.getStackLabel(stack.idx) }\r\n          count={stack.count}\r\n          score={stack.score}\r\n          subScore={stack.subScore}\r\n          meta={stack.meta} />\r\n      )}\r\n      <S.Bg>\r\n        <S.BgText src={'./assets/bg/stack-details-text.png'}/>\r\n        <S.BgShape />\r\n      </S.Bg>\r\n    </S.Container>\r\n  );\r\n}\r\n\r\nexport default StackInfo;\r\n","import React, { useState, useContext, useCallback, useRef } from 'react';\r\nimport { StoreContext } from '../../store/context';\r\nimport Card from './card';\r\n\r\nconst S = {};\r\n\r\nfunction HandCard({ data, theme='white' }) {\r\n  const { actions } = useContext(StoreContext);\r\n\r\n  const [ state, setState ] = useState({\r\n    dragPosition: null\r\n  });\r\n\r\n  const cardRef = useRef(null);\r\n  \r\n  const onMouseOver = useCallback((e, cardIdx, stackIdx) => {\r\n    actions.setFocusedCardIdx(cardIdx);\r\n    actions.setFocusedStackIdx(stackIdx);\r\n  }, [ actions.setFocusedStackIdx, actions.setFocusedCardIdx ]);\r\n\r\n\r\n  const onMouseDown = useCallback(({ clientX, clientY }, cardIdx) => {\r\n    actions.holdCard(cardIdx, {\r\n      x: clientX,\r\n      y: clientY\r\n    });\r\n  }, [ actions.holdCard, actions.dropCard ]);\r\n\r\n  return (\r\n    <Card\r\n      data={data}\r\n      theme={theme} \r\n      onMouseDown={onMouseDown}\r\n      onMouseOver={onMouseOver}\r\n      cardRef={cardRef}\r\n      inHand={true}\r\n      position={{x:0,y:0}}\r\n      dragPosition={state.dragPosition}\r\n      stackStyle={'hand'} >\r\n    </Card>\r\n  );\r\n}\r\n\r\nexport default HandCard;\r\n","import React, { useContext, useMemo } from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport { StoreContext } from '../../../store/context';\r\nimport HandCard from '../../../components/card/hand-card';\r\nimport { CARDSTATUS } from '../../../utils/constants';\r\n\r\nconst S = {};\r\n\r\nS.Hand = styled.div`\r\n  position:absolute;\r\n  width:100%;\r\n  height:6rem;\r\n  bottom:0px;\r\n\r\n  background-color:black;\r\n  border-top: 1rem solid white;\r\n`;\r\n\r\nfunction Hand() {\r\n  const { hand } = useContext(StoreContext);\r\n\r\n  const cardsInHand = useMemo(() => {\r\n      const validCards = hand.filter(h => h.status === CARDSTATUS.HAND).map((c, idx) => ({\r\n        ...c,\r\n        handPosition: idx\r\n      }));\r\n      return validCards;\r\n    },\r\n    [ hand ]\r\n  );\r\n  // const cardsInHand = [];\r\n\r\n  return (\r\n    <S.Hand id=\"hand\">\r\n      {cardsInHand.map(c => (\r\n        <HandCard data={c} key={c.cardIdx} />\r\n      ))}\r\n    </S.Hand>\r\n  );\r\n}\r\n\r\nexport default Hand;\r\n","import { CARDSTATUS } from '../../utils/constants';\r\nimport ThisModule from './deckmaker';\r\n\r\nconst parseMeta = (metaArray, scoreMap) => {\r\n  if(!metaArray) return [];\r\n\r\n  return metaArray.map(m => ({\r\n    tag: m[0],\r\n    value: m[1],\r\n    type: typeof m[1],\r\n    score: scoreMap[m[0]] || 0\r\n  }));\r\n}\r\n\r\nconst getCompleteCardUrl = (c, deckPath) => {\r\n  if(c.assetPath){\r\n    return `${deckPath}/assets/${c.assetPath}`;\r\n  }else if(c.imageUrl){\r\n    return c.imageUrl;\r\n  }else{\r\n    return './assets/cards/sample.jpg';\r\n  }\r\n}\r\n\r\nconst createDeckFromData = (deckName, deckList, scoreMap) => {\r\n  let deckIdx = 0;\r\n  return deckList.map(c => ({\r\n    title: c.title || 'no title',\r\n    imageUrl: ThisModule.getCompleteCardUrl(c, `./packs/${deckName}`),\r\n    meta: ThisModule.parseMeta(c.meta, scoreMap),\r\n    deckIdx: deckIdx++\r\n  })).flat()\r\n};\r\n\r\n/* too lazy to make the cards stack in a pile right now */\r\nlet shifter = 0;\r\nconst getInitialPlacement = () => {\r\n  shifter += 2;\r\n  return {\r\n    x: 250 + shifter,\r\n    y: 200 + shifter\r\n  }\r\n}\r\n\r\nconst getRandomPositionOnStage = () => {\r\n  const wClamp = 200;\r\n  const hClamp = 150;\r\n\r\n  const w = window.innerWidth - (wClamp * 2);\r\n  const h = window.innerHeight - (hClamp * 2);\r\n\r\n  return {\r\n    x: wClamp + Math.floor(Math.random() * w),\r\n    y: hClamp + Math.floor(Math.random() * h),\r\n  }\r\n}\r\n\r\nconst filterDeckToWhatsLeft = (activeCards, deck, workOrder) => {\r\n  if(!workOrder) workOrder = [];\r\n\r\n  return deck.filter((dC,idx) => {\r\n    const inPlay = activeCards.find(aC => aC.deckIdx === dC.deckIdx) || workOrder.indexOf(dC.deckIdx) > -1;\r\n    return !inPlay;\r\n  });\r\n}\r\n\r\nconst getStartIdxForHand = hand => {\r\n  try{\r\n    if(!hand || hand.length === 0) return 0;\r\n    return hand[hand.length - 1].cardIdx + 1;\r\n  }catch(e){\r\n    console.error('couldnt get start index with hand', hand)\r\n    return 0;\r\n  }\r\n}\r\n\r\nconst produceDeckHand = (deck, hand, cardLayer) => {\r\n  const newHand = [];\r\n  const workOrder = [];\r\n  let startIdx = 0;\r\n  if(cardLayer === undefined){\r\n    cardLayer = 1;\r\n  }\r\n\r\n  /* this is stupid and complicated */\r\n  if(hand){\r\n    startIdx = getStartIdxForHand(hand);\r\n  }else{\r\n    hand = [];\r\n  }\r\n\r\n  for(let i = 0; i < deck.length; i++){\r\n    let newCard = ThisModule.produceCard((i + startIdx), deck, hand, workOrder, cardLayer++);\r\n    if(newCard){\r\n      workOrder.push(newCard.deckIdx);\r\n    }\r\n    newCard && newHand.push(newCard);\r\n  }\r\n  \r\n  return newHand;\r\n}\r\n\r\nconst produceHand = (cardCount, deck, hand, cardLayer) => {\r\n  const newHand = [];\r\n  const workOrder = [];\r\n  let startIdx = 0;\r\n  if(cardLayer === undefined){\r\n    cardLayer = 1;\r\n  }\r\n\r\n  /* this is stupid and complicated */\r\n  if(hand){\r\n    startIdx = getStartIdxForHand(hand);\r\n  }else{\r\n    hand = [];\r\n  }\r\n\r\n  for(let i = 0; i < cardCount; i++){\r\n    let newCard = ThisModule.produceCard((i + startIdx), deck, hand, workOrder, cardLayer++);\r\n    if(newCard){\r\n      workOrder.push(newCard.deckIdx);\r\n    }\r\n    newCard && newHand.push(newCard);\r\n  }\r\n  \r\n  return newHand;\r\n}\r\n\r\n/* some mutation going on here needs to get fixed */\r\n/* supports producing multiple cards outside of state, kinda sloppy */\r\nconst produceCard = (cardIdx, deck, hand, workOrder, topLayer) => {\r\n  let filteredDeck = ThisModule.filterDeckToWhatsLeft(hand, deck, workOrder);\r\n  if(!filteredDeck || filteredDeck.length === 0){\r\n    console.warn('the deck is empty!')\r\n    return null;\r\n  }\r\n\r\n  let randIdx = Math.floor(Math.random() * filteredDeck.length);\r\n  let deckCard = filteredDeck[randIdx];\r\n  let newPos = getInitialPlacement();\r\n\r\n  return {\r\n    cardIdx: cardIdx,\r\n    deckIdx: deckCard.deckIdx,\r\n    info: deckCard,\r\n    status: CARDSTATUS.HAND,\r\n    layer: topLayer,\r\n    position: newPos\r\n  }\r\n};\r\n\r\nconst getCardAtIdx = (cardData, cardIdx) => {\r\n  const card = cardData[cardIdx];\r\n  if(!card) return null;\r\n\r\n  return card;\r\n};\r\n\r\nexport default {\r\n  createDeckFromData: createDeckFromData,\r\n  parseMeta: parseMeta,\r\n  produceCard: produceCard,\r\n  getCardAtIdx: getCardAtIdx,\r\n  filterDeckToWhatsLeft: filterDeckToWhatsLeft,\r\n  produceHand: produceHand,\r\n  produceDeckHand: produceDeckHand,\r\n  getCompleteCardUrl: getCompleteCardUrl\r\n};\r\n","import ThisModule from './gamemaster';\r\nimport DeckMaker from './deckmaker';\r\n\r\nconst store = {\r\n  'rounds': [],\r\n  'cardPack': [],\r\n  'scoreMap': [],\r\n  'name': null\r\n};\r\n\r\nconst setRoundData = (roundData, roundIdx) => {\r\n  store.rounds = roundData;\r\n}\r\n\r\nconst setCardPackData = (cardPackData, scoreMap, cardPackName) => {\r\n  store.scoreMap = scoreMap;\r\n  store.name = cardPackName;\r\n\r\n  let deckIdx = 0;\r\n  store.cardPack = cardPackData.map(c => ({\r\n    id: c.id,\r\n    title: c.title || 'no title',\r\n    imageUrl: DeckMaker.getCompleteCardUrl(c, `./packs/${cardPackName}`),\r\n    meta: DeckMaker.parseMeta(c.meta, scoreMap),\r\n    deckIdx: deckIdx++\r\n  })).flat();\r\n}\r\n\r\n\r\nconst getRound = (roundIdx) => {\r\n  try{\r\n    // console.log('getting round', roundIdx, store.rounds)\r\n    return store.rounds[roundIdx];\r\n  }catch(e){\r\n    console.error('could not retrieve current round');\r\n  }\r\n  \r\n}\r\n\r\nconst getNumRounds = () => {\r\n  return store.rounds.length;\r\n}\r\n\r\nconst getAdjacentRoundIdx = (curIdx, change) => {\r\n  const nextIdx = curIdx + change;\r\n  if(nextIdx < 0){\r\n    console.log('round is below 0!');\r\n    return -1;\r\n  }\r\n\r\n  if(store.rounds.length > nextIdx){\r\n    return nextIdx;\r\n  }else{\r\n    console.log('no more rounds!');\r\n    return -1;\r\n  }\r\n}\r\n\r\nconst getRoundData = (roundIdx) => {\r\n  console.log('getRoundData', roundIdx, store.rounds)\r\n  try{\r\n    return {\r\n      idx: roundIdx,\r\n      targetScore: store.rounds[roundIdx].targetScore,\r\n      title: store.rounds[roundIdx].title,\r\n    }\r\n  }catch(e){\r\n    return {\r\n      idx: -1,\r\n      targetScore: 2000\r\n    }\r\n  }\r\n}\r\nconst getCardPack = () => {\r\n  return store.cardPack;\r\n}\r\n\r\nconst getRoundDeck = (roundIdx) => {\r\n  console.log('getRoundDeck');\r\n  if(isNaN(roundIdx)){\r\n    console.error('getRoundDeck missing valid roundIdx', roundIdx);\r\n    return [];\r\n  }\r\n  const rD = ThisModule.getRound(roundIdx);\r\n  if(rD.deck){\r\n    let roundCardIds = ThisModule.getRound(roundIdx).deck;\r\n    return ThisModule.getCardPack().filter(c => roundCardIds.indexOf(c.id) > -1);\r\n  }else{\r\n    //- if no custom deck defined, give the whole thing\r\n    return ThisModule.getCardPack();\r\n  }\r\n}\r\n\r\nconst getStore = () => store;\r\n\r\nexport default {\r\n  setRoundData: setRoundData,\r\n  setCardPackData: setCardPackData,\r\n  getAdjacentRoundIdx: getAdjacentRoundIdx,\r\n  getRound: getRound,\r\n  getRoundDeck: getRoundDeck,\r\n  getRoundData: getRoundData,\r\n  getStore: getStore,\r\n  getCardPack: getCardPack,\r\n  getNumRounds: getNumRounds\r\n};\r\n","import React, { useContext, useMemo } from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport { StoreContext } from '../../../store/context';\r\nimport { getColor } from '../../../themes/index';\r\nimport GameMaster from '../../../store/helpers/gamemaster';\r\n\r\nconst S = {};\r\n\r\nS.Container = styled.div`\r\n  /* padding:1rem; */\r\n`;\r\n\r\nS.Bg = styled.div`\r\n  position:absolute;\r\n  z-index:-1;\r\n  left:0;\r\n  top:0;\r\n  right:0;\r\n  bottom:0;\r\n`;\r\n\r\nS.TextArea = styled.div`\r\n  position:absolute;\r\n  padding-top: 1rem;\r\n  top:100%;\r\n  width:100%;\r\n  left:0;\r\n  text-align:center;\r\n  color:${getColor('white')}\r\n`;\r\n\r\n\r\nS.ZoneText = styled.p`\r\n\r\n`;\r\nS.CardCount = styled.p`\r\n  font-size:1rem;\r\n`;\r\n\r\nS.BasicButton = styled.div`\r\n  display:inline-block;\r\n  padding: .5rem 1.5rem;\r\n  margin:.5rem;\r\n  font-size: 1rem;\r\n  background-color: ${getColor('purple')};\r\n  border-radius: 1rem;\r\n  font-weight: bold;\r\n  cursor:pointer;\r\n\r\n  border: .5rem solid ${getColor('white')};\r\n  color:${getColor('white')};\r\n  &:first-child{\r\n    margin-top:0;\r\n  }\r\n\r\n  &:hover{\r\n    background-color: ${getColor('green')};\r\n    /* color:${getColor('blue')}; */\r\n    box-shadow: 0 0 1rem .2rem white;\r\n  }\r\n\r\n  ${p => p.isActive && css`\r\n    background-color: ${getColor('blue')};\r\n  `}\r\n`;\r\n\r\nfunction RoundButton({ roundIdx, onClick, isActive }){\r\n  return(\r\n    <S.BasicButton isActive={isActive} onClick={() => onClick(roundIdx)} role=\"button\">\r\n      {`${roundIdx + 1}`}\r\n    </S.BasicButton>\r\n  )\r\n}\r\n\r\nfunction RoundZone() {\r\n  const { roundData, deck, hand, actions } = useContext(StoreContext);\r\n\r\n  const renderRounds = (count) => {\r\n    let buttons = [];\r\n    for(let i = 0; i < count; i++){\r\n      buttons.push(\r\n        <RoundButton \r\n          key={i}\r\n          roundIdx={i} \r\n          isActive={roundData.idx === i}\r\n          onClick={() => actions.setRound(i)} \r\n        />\r\n      );\r\n    }\r\n    return buttons;\r\n  }\r\n\r\n  const numCardsInDrawPile = useMemo(() => \r\n    deck.length - hand.length, \r\n    [ deck.length, hand.length ]\r\n  );\r\n\r\n  return (\r\n    <S.Container >\r\n      <S.BasicButton onClick={() => actions.prevRound()} role=\"button\">\r\n        {'-'}\r\n      </S.BasicButton>\r\n      { renderRounds(GameMaster.getNumRounds()) }\r\n      <S.BasicButton onClick={() => actions.nextRound()} role=\"button\">\r\n        {'+'}\r\n      </S.BasicButton>\r\n      <S.TextArea>\r\n        <S.ZoneText>{`Round: ${roundData.idx + 1}: \"${roundData.title}\"`}</S.ZoneText>\r\n        <S.CardCount>{`${numCardsInDrawPile} cards left`}</S.CardCount>\r\n      </S.TextArea>\r\n      <S.Bg />\r\n    </S.Container>\r\n  );\r\n}\r\n\r\nexport default RoundZone;\r\n","import React, { useContext, useMemo } from 'react';\nimport styled, { css } from 'styled-components';\nimport { StoreContext } from '../../../store/context';\nimport MetaHelper from '../../../store/helpers/meta';\nimport { getColor } from '../../../themes/index';\n\nconst S = {};\n\nS.Container = styled.div`\n  padding-right:11rem;\n  padding-top:10rem;\n  font-size:1rem;\n`;\n\n\nS.Bg = styled.div`\n  position:absolute;\n  left:0;\n  top:0;\n  right:0;\n  bottom:0;\n  border: 2rem solid ${getColor('white')};\n  background-color:${getColor('blue')};\n  border-radius: 50%;\n  z-index:-1;\n\n  &:hover{\n    box-shadow: 0 0 1rem .2rem ${getColor('white')};\n  }\n`;\n\n\nS.ScoreGroup = styled.div`\n  text-align:right;\n`;\n\nS.TotalScore = styled.div`\n  >p{\n    &:nth-child(1){\n      font-size:2.5rem;\n      color:${getColor('white')};\n    }\n\n    /* the score  */\n    &:nth-child(2){\n      font-size: 5rem;\n      margin-top: -2.5rem;\n      margin-bottom: -1.5rem;\n      color:${getColor('ui_blue')};\n    }\n  }\n`;\n\nS.TargetScore = styled.div`\n  >p{\n    &:nth-child(1){\n      font-size:1.5rem;\n      color:${getColor('white')};\n    }\n\n    /* the score  */\n    &:nth-child(2){\n      font-size: 3rem;\n      margin-top: -1.5rem;\n      color:${getColor('ui_orange')};\n    }\n  }\n`;\n\nS.SubScore = styled.div`\n  >p{\n    /* label */\n    &:nth-child(1){\n      color:white;\n    }\n    /* the score  */\n    &:nth-child(2){\n      font-size: 2rem;\n      color:${getColor('blue')};\n    }\n  }\n`;\n\nfunction InfoZone() {\n  const { stacks, hand, roundData } = useContext(StoreContext);\n  const completeStacks = useMemo(() => \n    MetaHelper.calcCompleteStacks(stacks, hand),\n    [ stacks, hand ]\n  );\n\n  const totalScore = useMemo(() => \n    MetaHelper.calcTotalScore(completeStacks), \n    [ completeStacks ]\n  );\n  \n  const ppcScore = useMemo(() => \n    MetaHelper.calcSpcScore(totalScore, hand.length), \n    [ totalScore, hand.length ]\n  );\n\n  return (\n    <S.Container >\n      <S.ScoreGroup>\n        <S.TotalScore>\n          <p>{'TOTAL'}</p>\n          <p>{totalScore}</p>\n        </S.TotalScore>\n        <S.TargetScore>\n          <p>{'TARGET'}</p>\n          <p>{roundData.targetScore}</p>\n        </S.TargetScore>\n      </S.ScoreGroup>\n      <S.Bg/>\n    </S.Container>\n  );\n}\n\nexport default InfoZone;\n","import React, { useContext, useCallback, useEffect, useMemo } from 'react';\r\nimport styled from 'styled-components';\r\nimport { StoreContext } from '../../store/context';\r\nimport ActiveCard from '../../components/card/active-card';\r\nimport { getColor } from '../../themes/index';\r\nimport DrawZone from './components/draw-zone';\r\nimport DropZone from './components/drop-zone';\r\nimport StackZone from './components/stack-zone';\r\nimport HandZone from './components/hand-zone';\r\nimport StackConsole from './components/stack-console';\r\nimport RoundZone from './components/round-zone';\r\nimport InfoZone from './components/info-zone';\r\nimport { CARDSTATUS } from '../../utils/constants';\r\n\r\nconst S = {};\r\n\r\n\r\nS.Board = styled.div`\r\n  position:absolute;\r\n  top:0;\r\n  left:0;\r\n  right:0;\r\n  bottom:0;\r\n  text-align:center;\r\n  z-index:2;\r\n`;\r\n\r\nS.PlayArea = styled.div`\r\n  position:relative;\r\n  width:100%;\r\n  height:100%;\r\n  overflow:hidden;\r\n`;\r\n\r\nS.DrawZone = styled.div`\r\n  position:absolute;\r\n  z-index:99999999;\r\n  top:1rem;\r\n  left:1rem;\r\n`;\r\n\r\nS.RoundZone = styled.div`\r\n  position:absolute;\r\n  z-index:99999999;\r\n  top:1rem;\r\n  left:16rem;\r\n  right:20rem;\r\n`;\r\n\r\nS.InfoZone = styled.div`\r\n  position:absolute;\r\n  z-index:99999999;\r\n  top:-12rem;\r\n  right:-10rem;\r\n  width: 30rem;\r\n  height: 30rem;\r\n  pointer-events:none;\r\n`;\r\n\r\nS.StackInfoZone = styled.div`\r\n  position:absolute;\r\n  z-index:1;\r\n  bottom: 0rem;\r\n  right: 0rem;\r\n  width: 46rem;\r\n  height: 30rem;\r\n`;\r\n\r\nS.DiscardZone = styled.div`\r\n  position:absolute;\r\n  bottom:0rem;\r\n  left:0rem;\r\n  width: 100%;\r\n  height: 13rem;\r\n`;\r\n\r\nS.Bg = styled.div`\r\n  position: absolute;\r\n  top:0;\r\n  left:0;\r\n  background-color: ${getColor('black')};\r\n  width:100%;\r\n  height:100%;\r\n  z-index:-9999999;\r\n`;\r\n\r\n\r\nS.BgImage = styled.img`\r\n  width: 2000px;\r\n  top:0;\r\n  left:0;\r\n`;\r\n\r\nS.CardContainer = styled.div`\r\n\r\n`;\r\n\r\nS.HeldCardContainer = styled.div`\r\n  position:absolute;\r\n  left:0;\r\n  top:0;\r\n`;\r\n\r\nfunction Board() {\r\n  const { actions, hand, dataLoaded  } = useContext(StoreContext);\r\n\r\n  /* unhovering stack makes the highlight go away */\r\n  const onBgMouseOver = useCallback(() => {\r\n    actions.setFocusedStackIdx(-1);\r\n    actions.setFocusedCardIdx(-1);\r\n  }, [ actions.setFocusedStackIdx, actions.setFocusedCardIdx ]);\r\n\r\n  useEffect(() => {\r\n    const urlParams = new URLSearchParams(window.location.search);\r\n    const packUrl = urlParams.get('pack');\r\n    if(packUrl){\r\n      actions.loadData(packUrl);\r\n    }else{\r\n      actions.loadData();\r\n    }\r\n  }, [ actions.loadData ]);\r\n\r\n  const cardsOnTable = useMemo(() => \r\n    hand.filter(h => h.status > CARDSTATUS.HAND && h.status < CARDSTATUS.DISCARDED),\r\n    [ hand ]\r\n  );\r\n\r\n  if(!dataLoaded){\r\n    return <h1>{'Loading...'}</h1>\r\n  }\r\n\r\n  return (\r\n    <S.Board>\r\n      <HandZone />\r\n      <S.DrawZone>\r\n        <DrawZone />\r\n      </S.DrawZone>\r\n      <S.RoundZone>\r\n        <RoundZone />\r\n      </S.RoundZone>\r\n      <S.InfoZone>\r\n        <p>{'info'}</p>\r\n        <InfoZone />\r\n      </S.InfoZone>\r\n      <S.DiscardZone>\r\n        <DropZone action={'discard'} />\r\n      </S.DiscardZone>\r\n      {/* <S.StackInfoZone>\r\n        <StackZone />\r\n      </S.StackInfoZone> */}\r\n      <StackConsole />\r\n\r\n\r\n      <S.CardContainer id=\"cc\">\r\n        {cardsOnTable.map((c, idx) => \r\n          <ActiveCard data={c} key={c.cardIdx} />\r\n        )}\r\n      </S.CardContainer>\r\n\r\n      {/* <S.HeldCardContainer id=\"hcc\">\r\n        {heldCard && (\r\n          <SimpleCard data={heldCard} key={heldCard.cardIdx} />\r\n        )}\r\n      </S.HeldCardContainer> */}\r\n      \r\n      <S.Bg onMouseOver={onBgMouseOver}>\r\n        {/* <S.BgImage src={'./assets/bg/bg1.jpg' } /> */}\r\n        <S.BgImage src={'./assets/bg/space.jpg' } />\r\n      </S.Bg>\r\n    </S.Board>\r\n  );\r\n}\r\n\r\nexport default Board;\r\n","const loadData = (url, callback) => {\r\n  console.log(`loading data ${url}...`);\r\n  var xhr = new XMLHttpRequest();\r\n  xhr.open('GET', url);\r\n  xhr.send(null);\r\n\r\n  xhr.onreadystatechange = function () {\r\n    var DONE = 4; // readyState 4 means the request is done.\r\n    var OK = 200; // status 200 is a successful return.\r\n    try{\r\n      if (xhr.readyState === DONE) {\r\n        if (xhr.status === OK) {\r\n          console.log(`...data was loaded!`);\r\n          //- the response is just text, so parse it into a JSON object\r\n          var gameData = JSON.parse(xhr.responseText);\r\n          callback(gameData);\r\n        } else {\r\n          console.error(`Error loading data from ${url}. Perhaps the file is not found?: `, xhr.status); // An error occurred during the request.\r\n        }\r\n      }\r\n    }catch(e){\r\n      console.error(`Error loading data from ${url}. Perhaps the JSON is malformed?`, e);\r\n    }\r\n  };\r\n}\r\n\r\nexport default {\r\n  loadData: loadData\r\n};\r\n","import React, { useState, useCallback } from 'react';\r\nimport { StoreContext } from './context';\r\nimport StackHelper from './helpers/stack';\r\nimport DeckMaker from './helpers/deckmaker';\r\nimport GameMaster from './helpers/gamemaster';\r\nimport DataHelper from './helpers/data';\r\nimport { CARDSTATUS } from '../utils/constants';\r\n\r\nlet topLayer = 0;\r\n\r\n// const DEFAULT_PACK = 'sample';\r\nconst DEFAULT_PACK = 'traditional';\r\n\r\n\r\nfunction Store({children}) {\r\n  const [ holdingIdx, setHoldingIdx ] = useState(-1);\r\n  const [ focusedStackIdx, setFocusedStackIdx ] = useState(-1);\r\n  const [ focusedCardIdx, setFocusedCardIdx ] = useState(-1);\r\n  const [ hand, setHandRaw ] = useState([]);\r\n  const [ deck, setDeck ] = useState([]);\r\n  const [ zones, setZones ] = useState([]);\r\n  const [ stacks, setStacks ] = useState([]);\r\n  const [ dataLoaded, setDataLoaded ] = useState(false);\r\n  const [ roundData, setRoundData ] = useState({});\r\n\r\n  const setAllRoundData =  useCallback(newRoundIdx => {\r\n    setRoundData(GameMaster.getRoundData(newRoundIdx));\r\n  }, [ setRoundData ]);\r\n\r\n  const loadData = useCallback(packName => {\r\n    packName = packName || DEFAULT_PACK;\r\n\r\n    const dataUrl = `./packs/${packName}/data.json`;\r\n    // console.log('loading data from ', dataUrl);\r\n    DataHelper.loadData(dataUrl, (data) => {\r\n      try{\r\n        console.log('heres your data', data);\r\n        GameMaster.setRoundData(data.pack.rounds);\r\n        GameMaster.setCardPackData(data.pack.cards, data.pack.scoreMap, data.pack.name);\r\n\r\n        const roundIdx = 0;\r\n        setAllRoundData(roundIdx);\r\n        setDeck(GameMaster.getRoundDeck(roundIdx));\r\n        setDataLoaded(true);\r\n      }\r\n      catch(e){\r\n        console.error('problem intializing data', e)\r\n      }\r\n    });\r\n  }, [ setDataLoaded, setAllRoundData ]);\r\n\r\n  const setHand = useCallback((hand, responsibleIdx) => {\r\n    // console.log('setHand', responsibleIdx);\r\n    const stacks = StackHelper.calcStacks(hand);\r\n    setStacks(stacks);\r\n    // console.log('setStacks', stacks)\r\n    \r\n    const newHand = hand.map(c => ({\r\n      ...c,\r\n      stackIdx: stacks.findIndex(s => s.indexOf(c.cardIdx) > -1)\r\n    }));\r\n\r\n    setHandRaw(newHand);\r\n    if(responsibleIdx > -1){\r\n      setFocusedStackIdx(newHand.find(c => c.cardIdx === responsibleIdx).stackIdx);\r\n    }\r\n  }, [ setHandRaw, setStacks, setFocusedStackIdx ]);\r\n\r\n  const discardCard = useCallback(cardIdx => {\r\n    setHand(hand.filter(h => h.cardIdx !== cardIdx));\r\n  }, [ setHand, hand ]);\r\n\r\n  const dealHand = useCallback(cardLimit => {\r\n    topLayer = 1;\r\n    const newHand = DeckMaker.produceHand(deck.length - (cardLimit || 0), GameMaster.getRoundDeck(roundData.idx), [], topLayer);\r\n\r\n    topLayer += newHand.length;\r\n    setHand(newHand);\r\n  }, [ setHand, roundData.idx, deck ]);\r\n\r\n  const dealCard = useCallback(cardCount => {\r\n    const newHand = DeckMaker.produceHand(cardCount, GameMaster.getRoundDeck(roundData.idx), hand, topLayer);\r\n\r\n    topLayer += newHand.length;\r\n    setHand(hand.concat(newHand));\r\n  }, [ setHand, hand, roundData.idx ]);\r\n\r\n  const discardHand = useCallback(() => {\r\n    topLayer = 1;\r\n    setHand([]);\r\n  }, [ setHand ]);\r\n\r\n  const discardRandomCard = useCallback(() => {\r\n    if(hand.length > 0){\r\n      const randHandIdx = Math.floor(Math.random() * hand.length);\r\n      discardCard(hand[randHandIdx].cardIdx);\r\n    }\r\n  }, [ discardCard, hand ]);\r\n  \r\n  /* this zone junk needs some work */\r\n  const setZone = useCallback((zoneId, bounds) => {\r\n    if(zones.find(z => z.id === zoneId)){\r\n      setZones(zones.map(z => {\r\n        if(z.id === zoneId){\r\n          return {\r\n            ...z,\r\n            bounds: {\r\n              top: bounds.top,\r\n              left: bounds.left,\r\n              right: bounds.right,\r\n              bottom: bounds.bottom\r\n            }\r\n          }\r\n        }else{\r\n          return z;\r\n        }\r\n      }));\r\n    }else{\r\n      setZones(zones.concat([\r\n        {\r\n          id:zoneId,\r\n          bounds: {\r\n            top: bounds.top,\r\n            left: bounds.left,\r\n            right: bounds.right,\r\n            bottom: bounds.bottom\r\n          }\r\n        }\r\n      ]))\r\n    }\r\n  }, [ zones, setZones ]);\r\n\r\n  const getZonesAtPosition = (position, zones) => {\r\n    return zones.filter(z => {\r\n      return (\r\n        (position.x > z.bounds.left && position.x < z.bounds.right)\r\n        && (position.y > z.bounds.top && position.y < z.bounds.bottom)\r\n      );\r\n    })\r\n  }\r\n\r\n  const nextRound = useCallback(() => {\r\n    const foundIdx = GameMaster.getAdjacentRoundIdx(roundData.idx, 1);\r\n    if(foundIdx > -1){\r\n      discardHand();\r\n      setAllRoundData(foundIdx);\r\n      setDeck(GameMaster.getRoundDeck(foundIdx));\r\n    }else{\r\n      console.log('nextRound, end of rounds!');\r\n    }\r\n  }, [ roundData.idx, setAllRoundData, discardHand ]);\r\n  \r\n  const prevRound = useCallback(() => {\r\n    const foundIdx = GameMaster.getAdjacentRoundIdx(roundData.idx, -1);\r\n    if(foundIdx > -1){\r\n      discardHand();\r\n      setAllRoundData(foundIdx);\r\n      setDeck(GameMaster.getRoundDeck(foundIdx))\r\n    }else{\r\n      console.log('nextRound, end of rounds!');\r\n    }\r\n  }, [ roundData.idx, setAllRoundData, discardHand ]);\r\n\r\n  const setRound = useCallback(roundIdx => {\r\n    const foundRound = GameMaster.getRound(roundIdx);\r\n    if(foundRound){\r\n      discardHand();\r\n      setAllRoundData(roundIdx);\r\n      setDeck(GameMaster.getRoundDeck(roundIdx))\r\n    }else{\r\n      console.log(`setRound, roundIdx \"${roundIdx}\" not found`);\r\n    }\r\n  }, [ setAllRoundData, discardHand ]);\r\n\r\n  const dropCardStatus = (status, location) => {\r\n    if(CARDSTATUS[location]){\r\n      return CARDSTATUS[location];\r\n    };\r\n\r\n    if(status === CARDSTATUS.HAND_HOLDING){\r\n      return CARDSTATUS.HAND;\r\n    }else if(status === CARDSTATUS.TABLE_HOLDING){\r\n      return CARDSTATUS.TABLE;\r\n    }else{\r\n      return status;\r\n    }\r\n  }\r\n\r\n  const holdCardStatus = status => {\r\n    if(status === CARDSTATUS.HAND){\r\n      return CARDSTATUS.HAND_HOLDING;\r\n      // return CARDSTATUS.TABLE;\r\n    }else if(status === CARDSTATUS.TABLE){\r\n      return CARDSTATUS.TABLE_HOLDING;\r\n    }else{\r\n      return status;\r\n    }\r\n  }\r\n\r\n  const holdCard = useCallback((cardIdx, position) => {\r\n    setHoldingIdx(cardIdx);\r\n\r\n    setHand(hand.map(c => {\r\n      if(c.cardIdx === cardIdx){\r\n        return {\r\n          ...c,\r\n          status:holdCardStatus(c.status),\r\n          position: position ? position : c.position\r\n        }\r\n      }else{\r\n        const droppedStatus = dropCardStatus(c.status);\r\n        if(c.status !== droppedStatus){\r\n          return {\r\n            ...c,\r\n            status: droppedStatus\r\n          }\r\n        }else{\r\n          return c;\r\n        }\r\n      }\r\n    }));\r\n  }, [ setHoldingIdx, hand, setHand ]);\r\n\r\n  const placeCardInHand = useCallback(cardIdx => {\r\n    setHand(hand.map(c => {\r\n      if(c.cardIdx === cardIdx){\r\n        return {\r\n          ...c,\r\n          status:CARDSTATUS.HAND\r\n        }\r\n      }\r\n      return c;\r\n    }));\r\n  }, [ setHoldingIdx, hand, setHand ]);\r\n\r\n  /*\r\n  const dropCard = useCallback((cardIdx, location, newPosition) => {\r\n    // console.log('drop ', cardIdx);\r\n    setHoldingIdx(-1);\r\n    if(cardIdx === holdingIdx){\r\n      setHoldingIdx(-1);\r\n    }\r\n\r\n    setHand(hand.map(c => {\r\n      if(c.cardIdx === cardIdx){\r\n        return {\r\n          ...c,\r\n          status:dropCardStatus(c.status, location),\r\n          layer: topLayer++,\r\n          position: newPosition ? {\r\n            x: newPosition.x,\r\n            y: newPosition.y\r\n          } : c.position\r\n        }\r\n      }\r\n      \r\n      return c;\r\n    }));\r\n  }, [ setHoldingIdx, hand, setHand, holdingIdx ]);\r\n  */\r\n\r\n  const dropCard = useCallback((cardIdx, location, newPosition) => {\r\n    // console.log('drop ', cardIdx);\r\n    setHoldingIdx(-1);\r\n    if(cardIdx === holdingIdx){\r\n      setHoldingIdx(-1);\r\n    }\r\n\r\n    const foundCard = hand.find(c => c.cardIdx === cardIdx);\r\n    if(foundCard && location === 'TABLE'){\r\n      let activeZones = [];\r\n      if(foundCard){\r\n        activeZones = getZonesAtPosition(newPosition, zones);\r\n      }\r\n\r\n      if(activeZones.find(az => az.id === 'hand')){\r\n        placeCardInHand(cardIdx);\r\n\r\n        return;\r\n      }\r\n    }\r\n\r\n    setHand(hand.map(c => {\r\n      if(c.cardIdx === cardIdx){\r\n        return {\r\n          ...c,\r\n          status:dropCardStatus(c.status, location),\r\n          layer: topLayer++,\r\n          position: newPosition ? {\r\n            x: newPosition.x,\r\n            y: newPosition.y\r\n          } : c.position\r\n        }\r\n      }\r\n      \r\n      return c;\r\n    }));\r\n  }, [ setHoldingIdx, hand, setHand, holdingIdx, zones, placeCardInHand ]);\r\n\r\n  return (\r\n    <StoreContext.Provider \r\n      value={{\r\n        dataLoaded: dataLoaded,\r\n        deck: deck,\r\n        hand: hand,\r\n        stacks: stacks,\r\n        zones: zones,\r\n        roundData: roundData,\r\n        holdingIdx: holdingIdx,\r\n        focusedStackIdx: focusedStackIdx,\r\n        focusedCardIdx: focusedCardIdx,\r\n        actions:{\r\n          nextRound: nextRound,\r\n          prevRound: prevRound,\r\n          setRound: setRound,\r\n          dealHand: dealHand,\r\n          dealCard: dealCard,\r\n          discardCard: discardCard,\r\n          discardRandomCard: discardRandomCard,\r\n          discardHand: discardHand,\r\n          loadData: loadData,\r\n          setZone: setZone,\r\n          setHoldingIdx: setHoldingIdx,\r\n          setFocusedStackIdx: setFocusedStackIdx,\r\n          setFocusedCardIdx: setFocusedCardIdx,\r\n          holdCard: holdCard,\r\n          dropCard: dropCard,\r\n          placeCardInHand: placeCardInHand,\r\n        }\r\n      }}>\r\n        {children}\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\nexport default Store;\r\n","import React, { useContext, useEffect } from 'react';\nimport Board from '../board';\nimport GameMaster from '../../store/helpers/gamemaster';\nimport DeckMaker from '../../store/helpers/deckmaker';\nimport Store from '../../store';\nimport styled from 'styled-components';\n\nconst S = {};\nS.Container = styled.div`\n  position:absolute;\n  width:100%;\n  height:100%;\n  overflow:hidden;\n`;\n\nwindow.gm = GameMaster;\nwindow.dm = DeckMaker;\n\nfunction Main() {\n  return (\n    <S.Container>\n      <Store>\n        <Board />\n      </Store>\n    </S.Container>\n  );\n}\n\nexport default Main;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './themes/theme.scss';\nimport Main from './containers/main';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<Main />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","export const CARDSTATUS = {\r\n  'DECK':0,\r\n  'HAND':1,\r\n  'HAND_HOLDING':2,\r\n  'TABLE':3,\r\n  'TABLE_HOLDING':4,\r\n  'DISCARDED':5\r\n}\r\n\r\nexport const getCardStatusLabel = statusIdx => {\r\n  return Object.keys(CARDSTATUS).find(statusKey => CARDSTATUS[statusKey] === statusIdx) || 'NULL';\r\n}\r\n\r\nexport default {};","import React from 'react';\n\nexport const InitialState = {\n  holdingIdx: 0,\n  deck: [],\n  hand: []\n};\n\nexport const StoreContext = React.createContext(InitialState);","import ThisModule from './stack';\r\nimport { CARDSTATUS } from '../../utils/constants';\r\n\r\nconst BOUND_OFFSET = {\r\n  W: 50,\r\n  H: 75\r\n};\r\n\r\nconst isThisInThat = (aA, aB) => {\r\n  if(!aA || !aB) return false;\r\n  let foundIdx = aA.findIndex(a => aB.indexOf(a) > -1);\r\n  return foundIdx > -1;\r\n};\r\n\r\nconst mergeArrays = (aA, aB) => {\r\n  aA = aA || [];\r\n  aB = aB || [];\r\n  return aA.concat(aB.filter((b) => aA.indexOf(b) < 0));\r\n};\r\n\r\nconst produceBounds = position => {\r\n  return {\r\n    left: position.x - BOUND_OFFSET.W,\r\n    top: position.y - BOUND_OFFSET.H,\r\n    right: position.x + BOUND_OFFSET.W,\r\n    bottom: position.y + BOUND_OFFSET.H\r\n  }\r\n};\r\n\r\n// cards only start with position, calc the bounds once please\r\nconst createBoundedHand = hand => {\r\n  // only stack cards in play\r\n  return hand.filter(c => c.status === CARDSTATUS.TABLE).map(c => ({\r\n    cardIdx: c.cardIdx,\r\n    bounds: ThisModule.produceBounds(c.position)\r\n  }));\r\n};\r\n\r\nconst doesOverlap = (bA, bB) => {\r\n  return bA.top <= bB.bottom && bA.bottom >= bB.top && bA.left <= bB.right && bA.right >= bB.left;\r\n};\r\n\r\n// do some weird loopin to avoid checking the same pair twice\r\nconst getGroupPairs = boundedHand => {\r\n  const groupPairs = [];\r\n\r\n  // do some weird loopin to avoid checking the same pair twice\r\n  for(let a = 0; a < boundedHand.length; a++){\r\n    for(let b = a + 1; b < boundedHand.length; b++){\r\n      if(ThisModule.doesOverlap(boundedHand[a].bounds, boundedHand[b].bounds)){\r\n        groupPairs.push([boundedHand[a].cardIdx, boundedHand[b].cardIdx]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return groupPairs;\r\n}\r\n\r\nconst findStackWithMatch = (stacks, groupPair) => {\r\n  return stacks.findIndex(stack => (stack.indexOf(groupPair[0]) > -1 || stack.indexOf(groupPair[1]) > -1));\r\n}\r\n\r\n/*\r\n  //- now have a list of..\r\n    [0, 1]\r\n    [1, 2]\r\n    [4, 5]\r\n\r\n  // so convert to\r\n    [0, 1, 2]\r\n    [4, 5]\r\n*/\r\nconst mutateForGroupPairs = (stacks, groupPairs) => {\r\n  let matchFound = false;\r\n\r\n  // find the next stack\r\n  for(let i = groupPairs.length - 1; i >= 0; i--){\r\n    const foundStackIdx = ThisModule.findStackWithMatch(stacks, groupPairs[i]);\r\n    if(stacks.length === 0){\r\n      stacks.push(groupPairs[i]);\r\n      groupPairs.splice(i, 1);\r\n      matchFound = true;\r\n    } else if(foundStackIdx > -1){\r\n      stacks[foundStackIdx] = ThisModule.mergeArrays(stacks[foundStackIdx], groupPairs[i]);\r\n      groupPairs.splice(i, 1);\r\n      matchFound = true;\r\n    }\r\n  }\r\n  \r\n  if(!matchFound && groupPairs.length > 0){\r\n    stacks.push(groupPairs[groupPairs.length - 1]);\r\n  }\r\n\r\n  return {\r\n    stacks: stacks,\r\n    groupPairs: groupPairs\r\n  };\r\n}\r\n\r\nconst createRawStacks = givenGroupPairs => {\r\n  if(!givenGroupPairs || givenGroupPairs.length === 0) return [];\r\n\r\n  let stacks = [];\r\n  let remainingGroupPairs = givenGroupPairs.slice();\r\n  while(remainingGroupPairs.length > 0){\r\n    // find the next stack\r\n    const matchObj = ThisModule.mutateForGroupPairs(stacks, remainingGroupPairs);\r\n    stacks = matchObj.stacks;\r\n    remainingGroupPairs = matchObj.groupPairs;\r\n  }\r\n\r\n  return stacks;\r\n}\r\n\r\n/* This works, but sure seems like it could be simplified!\r\n  - compares bounds of all cards\r\n  - returns list of \"stacks\" of unique cardIdxs that are touching\r\n  - there is so much dirty mutation throughout here and probably some big inefficiencies\r\n  ->  [ [ 0, 2, 5], [ 1, 3 ] ]\r\n*/\r\nconst calcStacks = (hand) => {\r\n  const boundedHand = ThisModule.createBoundedHand(hand);\r\n  const groupPairs = ThisModule.getGroupPairs(boundedHand);\r\n  const rawStacks = ThisModule.createRawStacks(groupPairs);\r\n  return rawStacks;\r\n};\r\n\r\n\r\nconst getStackColor = (stackIdx) => {\r\n  switch(stackIdx){\r\n    case -1: return null;\r\n    case 0: return 'purple';\r\n    case 1: return 'blue';\r\n    case 2: return 'green';\r\n    case 3: return 'yellow';\r\n    case 4: return 'red';\r\n    case 5: return 'grey';\r\n    default: return 'black';\r\n  }\r\n};\r\n\r\nconst ALPHA = [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L' ]\r\nconst getStackLabel = stackIdx => {\r\n  return ALPHA[stackIdx] || '*';\r\n};\r\n\r\nexport default {\r\n  isThisInThat: isThisInThat,\r\n  mergeArrays: mergeArrays,\r\n  produceBounds: produceBounds,\r\n  createBoundedHand: createBoundedHand,\r\n  doesOverlap: doesOverlap,\r\n  getGroupPairs: getGroupPairs,\r\n  createRawStacks: createRawStacks,\r\n  findStackWithMatch: findStackWithMatch,\r\n  calcStacks: calcStacks,\r\n  mutateForGroupPairs: mutateForGroupPairs,\r\n  getStackColor: getStackColor,\r\n  getStackLabel: getStackLabel,\r\n};\r\n","const newMetaGroup = metaInfo => ({\n  tag: metaInfo.tag,\n  value: metaInfo.value,\n  score: metaInfo.score,\n  count: 1\n});\n\nconst mergeMetaGroup = (oldMeta, newMeta) => ({\n  ...oldMeta,\n  count: oldMeta.count + 1\n});\n\nconst produceCards = (cardIdxs, hand) => cardIdxs.map((cardIdx) => hand.find(h => h.cardIdx === cardIdx));\nconst foundInTags = (checkTag, tags) => tags.some(t => t === checkTag);\n\nconst calcStackMeta = ( cardIdxs, hand ) => {\n  const cards = produceCards(cardIdxs, hand);\n\n  let stackMeta = [];\n  let invalidatedTags = [];\n  cards.forEach(c => {\n    c.info.meta.forEach(cMeta => {\n      const foundIdx = stackMeta.findIndex(m => m.tag === cMeta.tag);\n      if(foundIdx > -1){\n        /* for now, tag/value combos must match for card to aggregate..\n           if \"color\":\"red\", dont wanna aggregate any new meta where \"color\":\"blue\", etc\n        */\n        if(stackMeta[foundIdx].value === cMeta.value){\n          stackMeta[foundIdx] = mergeMetaGroup(stackMeta[foundIdx], cMeta);\n        }else{\n          //- tag/value combo doesnt match for this card\n          //- maybe later, invalidate tag group\n          if(invalidatedTags.indexOf(cMeta.tag) === -1) invalidatedTags.push(cMeta.tag);\n        }\n      }else{\n        stackMeta.push(newMetaGroup(cMeta));\n      }\n    })\n  });\n\n  return stackMeta\n    .filter(sM => !foundInTags(sM.tag, invalidatedTags)) //- remove any invalid groups\n    .filter(sM => sM.count === cardIdxs.length); //- if meta doesnt match all, remove it (TODO, bonus cards later)\n}\n\nconst getSortedCardDetails = (cardStack, hand) => \n  cardStack.map(cIdx => {\n    const cdata = hand.find(c => c.cardIdx === cIdx);\n    return {\n      ...cdata.info,\n      layer: cdata.layer\n    }\n  }).sort((a,b) => (a.layer > b.layer) ? 1 : -1);\n\n/* external */\nconst calcCompleteStacks = (stacks, hand) => stacks.map((s, sIdx) => {\n  const stackMeta = calcStackMeta(s, hand);\n\n  return {\n    idx: sIdx,\n    cardIdxs: s,\n    cardDetails: getSortedCardDetails(s, hand),\n    count: s.length,\n    meta: stackMeta,\n    subScore: stackMeta.reduce(((totalScore, meta) => totalScore + meta.score), 0),\n    score: stackMeta.reduce(((totalScore, meta) => totalScore + (meta.count * meta.score)), 0)\n  }\n});\nconst calcTotalScore = completeStacks => completeStacks.reduce(((totalScore, curStack) => curStack.score + totalScore), 0);\nconst calcSpcScore = (totalScore, handLength) => (handLength > 0 && Math.round(totalScore / handLength)) || 0;\n\nexport default {\n  calcTotalScore: calcTotalScore,\n  calcSpcScore: calcSpcScore,\n  calcCompleteStacks: calcCompleteStacks,\n};\n"],"sourceRoot":""}